{
    "url": "https://docs.snowflake.com/en/user-guide/views-secure",
    "title": "Working with Secure Views | Snowflake Documentation",
    "paragraphs": [
        "This topic covers concepts and syntax for defining views and materialized views as secure.",
        "For a non-secure view, internal optimizations can indirectly expose data.",
        "Some of the internal optimizations for views require access to the underlying data in the base tables for the view. This access\nmight allow data that is hidden from users of the view to be exposed through user code, such as user-defined functions, or other\nprogrammatic methods. Secure views do not utilize these optimizations, ensuring that users have no access to the underlying data.",
        "For a non-secure view, the view definition is visible to other users.",
        "By default, the query expression used to create a standard view, also known as the view definition or text, is visible to users\nin various commands and interfaces. For details, see Interacting with Secure Views (in this topic).",
        "For security or privacy reasons, you might not wish to expose the underlying tables or internal structural details for a view.\nWith secure views, the view definition and details are visible only to authorized users (i.e. users who are granted the role that\nowns the view).",
        "Views should be defined as secure when they are specifically designated for data privacy (i.e. to limit access to sensitive data that\nshould not be exposed to all users of the underlying table(s)).",
        "Secure views should not be used for views that are defined solely for query convenience, such as views created to\nsimplify queries for which users do not need to understand the underlying data representation. Secure views can execute\nmore slowly than non-secure views.",
        "Tip",
        "When deciding whether to use a secure view, you should consider the purpose of the view and weigh the trade-off between data\nprivacy/security and query performance.",
        "Using the following widgets example, consider a user who has access to only the red widgets. Suppose the user wonders if any purple\nwidgets exist and issues the following query:",
        "If any purple widgets exist, then the IFF() expression returns 0. The division operation then fails due to a division-by-zero error,\nwhich allows the user to infer that at least one purple widget exists.",
        "Secure views are defined using the SECURE keyword with the standard DDL for views:",
        "To create a secure view, specify the SECURE keyword in the CREATE VIEW or\nCREATE MATERIALIZED VIEW command.",
        "To convert an existing view to a secure view and back to a regular view, set/unset the SECURE keyword in the\nALTER VIEW or ALTER MATERIALIZED VIEW command.",
        "The definition of a secure view is only exposed to authorized users (i.e. users who have been granted the role that owns the view). If an\nunauthorized user uses any of the following commands or interfaces, the view definition is not displayed:",
        "SHOW VIEWS and SHOW MATERIALIZED VIEWS commands.",
        "GET_DDL utility function.",
        "VIEWS Information Schema view.",
        "However, users that have been granted IMPORTED PRIVILEGES privilege on the SNOWFLAKE database or another shared database have access to secure view definitions via the VIEWS Account Usage view.",
        "Users granted the ACCOUNTADMIN role or the SNOWFLAKE.OBJECT_VIEWER database role can also see secure view definitions via this view. The preferred, least-privileged means of access is the SNOWFLAKE.OBJECT_VIEWER database role.",
        "For non-materialized views, the IS_SECURE column in the Information Schema and Account Usage views identifies whether a view is secure.\nFor example, for aview named MYVIEW in the mydb database:",
        "Information Schema:",
        "Account Usage:",
        "(For general information about the differences between INFORMATION_SCHEMA views and ACCOUNT_USAGE views, see\nDifferences between Account Usage and Information Schema.)",
        "Alternatively, you can use the SHOW VIEWS command to view similar information (note that the view name is case-insensitive):",
        "For materialized views, use the SHOW MATERIALIZED VIEWS command to identify whether a view is secure. For example:",
        "The internals of a secure view are not exposed in Query Profile (in the web interface). This is the\ncase even for the owner of the secure view, because non-owners might have access to an owner\u2019s Query Profile.",
        "View security can be integrated with Snowflake users and roles using the CURRENT_ROLE and\nCURRENT_USER context functions. The following example illustrates using roles to control access to the rows of\na table. In addition to the table that contains the data (widgets), the example uses an access table (widget_access_rules) to\ntrack which roles have access to which rows in the data table:",
        "The WHERE clause limits which widgets each role can see.",
        "Suppose that a user who has access only to red widgets executes the query shown earlier:",
        "The secure view\u2019s WHERE clause is executed before any WHERE clause in the user\u2019s query. Because purple widgets are excluded\nby the view, the user\u2019s query never generates a division-by-zero error.",
        "If the view were not secure, then the Snowflake optimizer could re-order the predicates in the WHERE clauses. This could allow\nthe predicate in the user\u2019s query to execute first, which would allow the division-by-zero error to occur.",
        "Secure views prevent users from possibly being exposed to data from rows of tables that are filtered by the view. However, there are still\nways that a data owner might inadvertently expose information about the underlying data if views are not constructed carefully. This section\ndiscusses some potential pitfalls to avoid.",
        "To illustrate these pitfalls, this section uses the sample widgets tables and view defined in the earlier examples in this topic.",
        "A common practice for generating surrogate keys is to use a sequence or auto-increment column. If these keys are exposed to users who do not\nhave access to all of the underlying data, then a user might be able to guess details of the underlying data distribution. For example,\nwidgets_view exposes the ID column. If ID is generated from a sequence, then a user of widgets_view could deduce the total\nnumber of widgets created between the creation timestamps of two widgets that the user has access to. Consider the following query and result:",
        "Based on the result, the user might suspect that 1139 widgets (1455 - 315) were created between January 7 and January 15. If this\ninformation is too sensitive to expose to users of a view, you can use any of the following alternatives:",
        "Do not expose the sequence-generated column as part of the view.",
        "Use randomized identifiers (e.g. generated by UUID_STRING) instead of sequence-generated values.",
        "Programmatically obfuscate the identifiers.",
        "For queries containing secure views, Snowflake does not expose the amount of data scanned (either in terms of bytes or micro-partitions)\nor the total amount of data. This is to protect the information from users who only have access to a subset of the data. However, users\nmight still be able to make observations about the quantity of underlying data based on performance characteristics of queries. For example,\na query that runs twice as long might process twice as much data. While any such observations are approximate at best, in some cases it\nmight be undesirable for even this level of information to be exposed.",
        "In such cases, it is best to materialize data per user/role instead of exposing views on the base data to users. In the case of the\nwidgets table, a table would be created for each role that has access to widgets, which contains only the widgets accessible by\nthat role, and a role would be granted access to its table. This is much more cumbersome than using a single view, but for extremely\nhigh-security situations, this might be warranted.",
        "When using secure views with Secure Data Sharing, use the CURRENT_ACCOUNT function to authorize users from a specific account to access rows in a base table.",
        "Note",
        "When using the CURRENT_ROLE and CURRENT_USER functions with secure\nviews that will be shared to other Snowflake accounts, Snowflake returns a NULL value for these functions. The reason is that the owner\nof the data being shared does not typically control the users or roles in the account with which the view is being shared.",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}