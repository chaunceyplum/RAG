{
    "url": "https://docs.snowflake.com/en/developer-guide/snowpark/reference/python/1.26.0/modin/pandas_api/modin.pandas.read_html",
    "title": "modin.pandas.read_html | Snowflake Documentation",
    "paragraphs": [
        "Read HTML tables into a list of DataFrame objects.",
        "io (str, path object, or file-like object) \u2013 String, path object (implementing os.PathLike[str]), or file-like object implementing a string read() function. The string can represent a URL. Note that lxml only accepts the http, ftp and file url protocols. If you have a URL that starts with \u2018https\u2019 you might try removing the \u2018s\u2019.",
        "match (str or compiled regular expression, optional) \u2013 The set of tables containing text matching this regex or string will be returned. Unless the HTML is extremely simple you will probably need to pass a non-empty string here. Defaults to \u2018.+\u2019 (match any non-empty string). The default value will return all tables contained on a page. This value is converted to a regular expression so that there is consistent behavior between Beautiful Soup and lxml.",
        "flavor ({\u201clxml\u201d, \u201chtml5lib\u201d, \u201cbs4\u201d} or list-like, optional) \u2013 The parsing engine (or list of parsing engines) to use. \u2018bs4\u2019 and \u2018html5lib\u2019 are synonymous with each other, they are both there for backwards compatibility. The default of None tries to use lxml to parse and if that fails it falls back on bs4 + html5lib.",
        "header (int or list-like, optional) \u2013 The row (or list of rows for a MultiIndex) to use to make the columns headers.",
        "index_col (int or list-like, optional) \u2013 The column (or list of columns) to use to create the index.",
        "skiprows (int, list-like or slice, optional) \u2013 Number of rows to skip after parsing the column integer. 0-based. If a sequence of integers or a slice is given, will skip the rows indexed by that sequence. Note that a single element sequence means \u2018skip the nth row\u2019 whereas an integer means \u2018skip n rows\u2019.",
        "attrs (dict, optional) \u2013 This is a dictionary of attributes that you can pass to use to identify the table in the HTML. These are not checked for validity before being passed to lxml or Beautiful Soup. However, these attributes must be valid HTML table attributes to work correctly. For example,\nattrs = {\u201cid\u201d: \u201ctable\u201d}\nis a valid attribute dictionary because the \u2018id\u2019 HTML tag attribute is a valid HTML attribute for any HTML tag as per this document.\nattrs = {\u201casdf\u201d: \u201ctable\u201d}\nis not a valid attribute dictionary because \u2018asdf\u2019 is not a valid HTML attribute even if it is a valid XML attribute. Valid HTML 4.01 table attributes can be found here. A working draft of the HTML 5 spec can be found here. It contains the latest information on table attributes for the modern web.",
        "parse_dates (bool, optional) \u2013 See read_csv() for more details.",
        "thousands (str, optional) \u2013 Separator to use to parse thousands. Defaults to \u2018,\u2019.",
        "encoding (str, optional) \u2013 The encoding used to decode the web page. Defaults to None.``None`` preserves the previous encoding behavior, which depends on the underlying parser library (e.g., the parser library will try to use the encoding provided by the document).",
        "decimal (str, default \u2018.\u2019) \u2013 Character to recognize as decimal point (e.g. use \u2018,\u2019 for European data).",
        "converters (dict, default None) \u2013 Dict of functions for converting values in certain columns. Keys can either be integers or column labels, values are functions that take one input argument, the cell (not column) content, and return the transformed content.",
        "na_values (iterable, default None) \u2013 Custom NA values.",
        "keep_default_na (bool, default True) \u2013 If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they\u2019re appended to.",
        "displayed_only (bool, default True) \u2013 Whether elements with \u201cdisplay: none\u201d should be parsed.",
        "extract_links ({None, \u201call\u201d, \u201cheader\u201d, \u201cbody\u201d, \u201cfooter\u201d}) \u2013 Table elements in the specified section(s) with <a> tags will have their href extracted.",
        "dtype_backend ({\u2018numpy_nullable\u2019, \u2018pyarrow\u2019}) \u2013 Back-end data type applied to the resultant DataFrame (still experimental). If not specified, the default behavior is to not use nullable data types. If specified, the behavior is as follows:\n- \u201cnumpy_nullable\u201d: returns nullable-dtype-backed DataFrame\n- \u201cpyarrow\u201d: returns pyarrow-backed nullable ArrowDtype DataFrame",
        "storage_options (dict, optional) \u2013 Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to urllib.request.Request as header options. For other URLs (e.g. starting with \u201cs3://\u201d, and \u201cgcs://\u201d) the key-value pairs are forwarded to fsspec.open. Please see fsspec and urllib for more details, and for more examples on storage options refer here.",
        "A list of DataFrames.",
        "dfs",
        "See also",
        "Read a comma-separated values (csv) file into DataFrame.",
        "Notes",
        "Before using this function you should read the gotchas about the HTML parsing libraries.",
        "Expect to do some cleanup after you call this function. For example, you might need to manually assign column names if the column names are converted to NaN when you pass the header=0 argument. We try to assume as little as possible about the structure of the table and push the idiosyncrasies of the HTML contained in the table to the user.",
        "This function searches for <table> elements and only for <tr> and <th> rows and <td> elements within each <tr> or <th> element in the table. <td> stands for \u201ctable data\u201d. This function attempts to properly handle colspan and rowspan attributes. If the function has a <thead> argument, it is used to construct the header, otherwise the function attempts to find the header within the body (by putting rows with only <th> elements into the header).",
        "Similar to read_csv() the header argument is applied after skiprows is applied.",
        "This function will always return a list of DataFrame or it will fail, i.e., it will not return an empty list, save for some rare cases. It might return an empty list in case of inputs with single row and <td> containing only whitespaces.",
        "Examples",
        "See the read_html documentation in the IO section of the docs for some examples of reading in HTML tables.",
        "Was this page helpful?"
    ]
}