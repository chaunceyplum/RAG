{
    "url": "https://docs.snowflake.com/en/sql-reference/functions/parse_json",
    "title": "PARSE_JSON | Snowflake Documentation",
    "paragraphs": [
        "Semi-structured and structured data functions (Parsing)",
        "Interprets an input string as a JSON document, producing a VARIANT value.",
        "You can use the PARSE_JSON function when you have input data in JSON format. This function can convert\ndata from JSON format to ARRAY or OBJECT data and store that\ndata directly in a VARIANT value. You can then analyze or manipulate the data.",
        "By default, the function doesn\u2019t allow duplicate keys in the JSON object, but you can set the\n'parameter' argument to allow duplicate keys.",
        "TRY_PARSE_JSON",
        "Required:",
        "An expression of string type (for example, VARCHAR) that holds valid JSON information.",
        "Optional:",
        "String constant that specifies the parameter used to search for matches. Supported values:",
        "Parameter",
        "Description",
        "d",
        "Allow duplicate keys in JSON objects. If a JSON object contains a duplicate key, the returned object has a single instance\nof that key with the last value specified for that key.",
        "s",
        "Don\u2019t allow duplicate keys in JSON objects (strict). This value is the default.",
        "Returns a value of type VARIANT that contains a JSON document.",
        "If the input is NULL, the function returns NULL.",
        "This function doesn\u2019t return a structured type.",
        "This function supports an input expression with a maximum size of 8 MB compressed.",
        "If the PARSE_JSON function is called with an empty string, or with a string containing only whitespace characters, then\nthe function returns NULL (rather than raising an error), even though an empty string isn\u2019t valid JSON. This behavior allows\nprocessing to continue rather than aborting if some inputs are empty strings.",
        "If the input is NULL, the output is also NULL. However, if the input string is 'null', then it is interpreted as a\nJSON null value so that the result isn\u2019t SQL NULL, but instead a valid VARIANT value containing null.\nSee the example below.",
        "When parsing decimal numbers, PARSE_JSON attempts to preserve the exactness of the representation by treating 123.45 as NUMBER(5,2),\nnot as a DOUBLE value. However, numbers that use scientific notation (for example, 1.2345e+02), or numbers that cannot be stored as fixed-point\ndecimals due to range or scale limitations, are stored as DOUBLE values. Because JSON does not represent values such as TIMESTAMP, DATE,\nTIME, or BINARY natively, these values must be represented as strings.",
        "In JSON, an object (also called a \u201cdictionary\u201d or a \u201chash\u201d) is an unordered set of\nkey-value pairs.",
        "TO_JSON and PARSE_JSON are (almost) converse or reciprocal functions.",
        "The PARSE_JSON function takes a string as input and returns a JSON-compatible VARIANT.",
        "The TO_JSON function takes a JSON-compatible VARIANT and returns a string.",
        "The following is (conceptually) true if X is a string containing valid JSON:",
        "X = TO_JSON(PARSE_JSON(X));",
        "For example, the following is (conceptually) true:",
        "'{\"pi\":3.14,\"e\":2.71}' = TO_JSON(PARSE_JSON('{\"pi\":3.14,\"e\":2.71}'))",
        "However, the functions are not perfectly reciprocal because:",
        "Empty strings, and strings with only whitespace, are not handled reciprocally. For example, the return value of\nPARSE_JSON('') is NULL, but the return value of TO_JSON(NULL) is NULL, not the reciprocal ''.",
        "The order of the key-value pairs in the string produced by TO_JSON is not predictable.",
        "The string produced by TO_JSON can have less whitespace than the string passed to PARSE_JSON.",
        "For example, the following are equivalent JSON, but not equivalent strings:",
        "{\"pi\": 3.14, \"e\": 2.71}",
        "{\"e\":2.71,\"pi\":3.14}",
        "The following examples use the PARSE_JSON function.",
        "This example stores different types of data in a VARIANT column by calling PARSE_JSON to parse strings.",
        "Create and fill a table. The INSERT statement uses PARSE_JSON to insert VARIANT values in the v column\nof the table.",
        "Query the data. The query uses the TYPEOF function to show the data types of\nthe values stored in the VARIANT values.",
        "Try to insert a JSON object with duplicate keys in a VARIANT value:",
        "An error is returned because duplicate keys aren\u2019t allowed by default:",
        "Insert a JSON object with duplicate keys in a VARIANT value, and specify the d parameter to allow\nduplicates:",
        "A query on the table shows that only the value of the last duplicate key was inserted:",
        "The following example shows how PARSE_JSON and TO_JSON handle NULL values:",
        "The following examples demonstrate the relationship between the PARSE_JSON and TO_JSON functions.",
        "This example creates a table with a VARCHAR column and a VARIANT column. The INSERT statement inserts\na VARCHAR value, and the UPDATE statement generates a JSON value that corresponds with that VARCHAR value.",
        "This query shows that TO_JSON and PARSE_JSON are conceptually reciprocal functions:",
        "However, the functions are not exactly reciprocal. Differences in whitespace or in the order of key-value\npairs can prevent the output from matching the input. For example:",
        "Although both the PARSE_JSON function and the TO_VARIANT function can take a string and return\na VARIANT value, they are not equivalent. The following example creates a table with two VARIANT\ncolumns. Then, it uses PARSE_JSON to insert a value into one column and TO_VARIANT to\ninsert a value into the other column.",
        "The query below shows that the functions returned VARIANT values that\nstore values of different data types.",
        "Was this page helpful?",
        "On this page"
    ]
}