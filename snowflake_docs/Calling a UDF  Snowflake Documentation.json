{
    "url": "https://docs.snowflake.com/en/developer-guide/udf/udf-calling-sql",
    "title": "Calling a UDF | Snowflake Documentation",
    "paragraphs": [
        "You can call a user-defined function (UDF) or user-defined table function (UDTF) in the same way that you call other functions.",
        "In general, you call a UDF same way that you call other functions.",
        "If a UDF has arguments, you can specify those arguments by name or by position.",
        "For example, the following UDF accepts three arguments:",
        "When calling the UDF, you can specify the arguments by name:",
        "If you specify the arguments by name, you do not need to specify the arguments in any particular order:",
        "You can also specify the arguments by position:",
        "Note the following:",
        "You must either specify all arguments by name or by position. You cannot specify some of the arguments by name and other\narguments by position.",
        "When specifying an argument by name, you cannot use double quotes around the argument name.",
        "If two functions or two procedures have the same name but different argument types, you can use the argument names to specify\nwhich function or procedure to execute, if the argument names are different. Refer to\nOverloading procedures and functions.",
        "If the UDF has optional arguments, you can omit the optional arguments in\nthe call. Each optional argument has a default value that is used when the argument is omitted.",
        "For example, the following UDF has one required argument and two optional arguments. Each optional argument has a default value.",
        "You can omit any of the optional arguments in the call. When you omit an argument, the default value of the argument is used.",
        "If you need to omit an optional argument and specify another optional argument that appears after the omitted argument in the\nsignature, use named arguments, rather than positional arguments.",
        "For example, suppose that you want to omit the prefix argument and specify the suffix argument. The suffix argument\nappears after the prefix in the signature, so you must specify the arguments by name:",
        "You can call a UDTF the way you would call any table function. When calling a UDTF in the FROM clause of a query, specify the\nUDTF\u2019s name and arguments inside the parentheses that follow the TABLE keyword, as you would when\ncalling a built-in table function.",
        "In other words, use a form such as the following for the TABLE keyword when calling a UDTF:",
        "Code in the following example calls the my_java_udtf table function, specifying a DATE literal in the argument\n'2021-01-16'::DATE.",
        "The argument to a table function can be an expression, not just a literal. For example, a table function can be called using\na column from a table. Some examples are below, including in the Examples section.",
        "As is the case with calling UDFs, you can specify the arguments by name or by position.",
        "For more information about table functions in general, see table function.",
        "Note",
        "You cannot call a UDF within the DEFAULT clause of a CREATE TABLE statement.",
        "The input to a table function can come from a table or from another UDTF, as documented in\nUsing a table as input to a table function.",
        "The example below shows how to use a table to provide input to the UDTF split_file_into_words:",
        "The output looks similar to the following:",
        "The IMPORTS clause of the UDTF must specify the name and path of each file passed to the UDTF. For example:",
        "Each file must already have been copied to a stage (in this case, the stage named @inline_jars) before the UDTF reads the file.",
        "For an example of using a UDTF as an input to another UDTF, see Extended examples using table values and other UDTFs as input in\nthe JavaScript UDTF documentation.",
        "Before rows are passed to table functions, the rows can be grouped into partitions. Partitioning has two main benefits:",
        "Partitioning allows Snowflake to divide up the workload to improve parallelization and thus performance.",
        "Partitioning allows Snowflake to process all rows with a common characteristic as a group.\nYou can return results that are based on all rows in the group, not just on individual rows.",
        "For example, you might partition stock price data into one group per stock. All stock prices for an individual company can be\nanalyzed together, while stock prices for each company can be analyzed independently of any other company.",
        "Data can be partitioned explicitly or implicitly.",
        "Explicit Partitioning into Multiple Groups",
        "The following statement calls the UDTF named my_udtf on individual partitions. Each partition contains all rows for which\nthe PARTITION BY expression evaluates to the same value (e.g. the same company or stock symbol).",
        "Explicit Partitioning into a Single Group",
        "The following statement calls the UDTF named my_udtf on one partition. The PARTITION BY <constant> clause\n(in this case PARTITION BY 1) puts all rows in the same partition.",
        "For a more complete and realistic example, see Examples of calling Java UDTFs in queries, in particular the subsection\ntitled Single Partition.",
        "Sorting Rows for Partitions",
        "To process each partition\u2019s rows in a specified order, include an ORDER BY clause. This tells Snowflake to pass the rows\nto the per-row handler method in the specified order.",
        "For example, if you want to calculate the moving average of a stock price over time, then order the stock prices by timestamp (and\npartition by stock symbol). The following example shows how to do this:",
        "An OVER clause can contain an ORDER BY clause even without a PARTITION BY clause.",
        "Remember that including an ORDER BY clause inside an OVER clause is not the same as putting an ORDER BY clause at the\noutermost level of the query. If you want the entire query results to be ordered, you need a separate ORDER BY clause. For\nexample:",
        "Usage Notes for Explicit Partitioning",
        "When using a UDTF with a PARTITION BY clause, the PARTITION BY clause must use a column reference or a literal,\nnot a general expression. For example, the following is not allowed:",
        "If a table function does not explicitly partition the rows by using a PARTITION BY clause, then Snowflake typically partitions\nthe rows implicitly to use parallel processing to improve performance.",
        "The number of partitions is typically based on factors such as the size of the warehouse processing the function and the\ncardinality of the input relation. The rows are typically assigned to specific partitions based on factors such\nas physical location of the rows (e.g. by micro-partition), so the partition grouping has no meaning.",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}