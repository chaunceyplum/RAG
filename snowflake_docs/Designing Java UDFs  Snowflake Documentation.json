{
    "url": "https://docs.snowflake.com/en/developer-guide/udf/java/udf-java-designing",
    "title": "Designing Java UDFs | Snowflake Documentation",
    "paragraphs": [
        "This topic helps you design Java UDFs.",
        "Before you write your code:",
        "Choose the data types your function should accept as arguments and the data\ntype your function should return.",
        "Take into account time-zone related issues.",
        "Decide how to handle NULL values.",
        "For information on how Snowflake converts between Java and SQL data types, see\nData Type Mappings Between SQL and Handler Languages.",
        "A Java UDF is largely isolated from the environment in which it is called. However, the timezone is inherited from\nthe calling environment. If the caller\u2019s session set a default time zone before calling the Java UDF, then the Java\nUDF has the same default time zone. Java UDF uses the same IANA Time Zone Database data as the native TIMEZONE\nSnowflake SQL uses (i.e. data from release 2021a of the Time Zone Database).",
        "Snowflake supports two distinct NULL values: SQL NULL and VARIANT\u2019s JSON null. (For information about Snowflake\nVARIANT NULL, see NULL Values.)",
        "Java supports one null value, which is only for non-primitive data types.",
        "A SQL NULL argument to a Java UDF translates to the Java null value, but only for Java data types that\nsupport null.",
        "A returned Java null value translates back to SQL NULL.",
        "Java UDFs can receive arrays of any of the following Java data types:",
        "String",
        "boolean",
        "double",
        "float",
        "int",
        "long",
        "short",
        "The data type of the SQL values passed must be compatible with the corresponding Java data type. For details about data type compatibility,\nsee SQL-Java Data Type Mappings.",
        "The following additional rules apply for each of the specified Java data types:",
        "boolean: The Snowflake ARRAY must contain only BOOLEAN elements, and must not contain any NULL values.",
        "int/short/long: The Snowflake ARRAY must contain only fixed-point elements with a\nscale of 0, and must not contain any NULL values.",
        "float/double: The Snowflake ARRAY must contain either:",
        "FLOAT elements.",
        "Fixed-point elements (with any scale).",
        "The ARRAY must not contain any NULL values.",
        "Java methods can receive these arrays in either of two ways:",
        "Using Java\u2019s array feature.",
        "Using Java\u2019s varargs (variable number of arguments) feature.",
        "In both cases, your SQL code must pass an ARRAY.",
        "Declare the Java parameter as an array. For example, the third parameter in the following method is a String array:",
        "Below is a complete example:",
        "Create and load the table:",
        "Create the UDF:",
        "Call the UDF:",
        "Using varargs is very similar to using an array.",
        "In your Java code, use Java\u2019s varargs declaration style:",
        "Below is a complete example. The only significant difference between this example and the preceding example (for arrays) is the\ndeclaration of the parameters to the method.",
        "Create and load the table:",
        "Create the UDF:",
        "Call the UDF:",
        "For information on designing handler code that runs well on Snowflake, see Designing Handlers that Stay Within Snowflake-Imposed Constraints.",
        "When a SQL statement calls your Java UDF, Snowflake calls a Java method you have written. Your Java method is called a\n\u201chandler method\u201d, or \u201chandler\u201d for short.",
        "As with any Java method, your method must be declared as part of a class. Your handler method can be a static method or an instance\nmethod of the class. If your handler is an instance method, and your class defines a zero-argument constructor, then Snowflake\ninvokes your constructor at initialization time to create an instance of your class. If\nyour handler is a static method, your class is not required to have a constructor.",
        "The handler is called once for each row passed to the Java UDF. (Note: a new instance of the class is not created for each row;\nSnowflake can call the same instance\u2019s handler method more than once, or call the same static method more than once.)",
        "To optimize execution of your code, Snowflake assumes that initialization might be slow, while execution of the handler method\nis fast. Snowflake sets a longer timeout for executing initialization (including the time to load your UDF and the time\nto call the constructor of the handler method\u2019s containing class, if a constructor is defined) than for executing the handler\n(the time to call your handler with one row of input).",
        "Additional information about designing the class is in Creating a Java UDF handler.",
        "Most function and procedure handlers should follow the guidelines below:",
        "If you need to initialize shared state that does not change across rows, initialize it outside the handler function, such as in the\nmodule or constructor.",
        "Write your handler function or method to be thread safe.",
        "Avoid storing and sharing dynamic state across rows.",
        "If your UDF cannot follow these guidelines, or if you would like a deeper understanding of the reasons for these guidelines,\nplease read the next few subsections.",
        "Snowflake expects scalar UDFs to be processed independently. Relying on state shared between invocations can result in unexpected\nbehavior. This is because the system can process rows in any order and spread those invocations across several JVMs (for handlers written\nin Java or Scala) or instances (for handlers written in Python).",
        "UDFs should avoid relying on shared state across calls to the handler method. However, there are two situations in which you might want a\nUDF to store shared state:",
        "Code that contains expensive initialization logic that you do not want to repeat for each row.",
        "Code that leverages shared state across rows, such as a cache.",
        "If you need to share state across multiple rows, and if that state does not change over time, then use a constructor to create\nshared state by setting instance-level variables. The constructor is executed only once per instance, while the handler is called\nonce per row, so initializing in the constructor is cheaper when a handler processes multiple rows. And because the constructor is\ncalled only once, the constructor does not need to be written to be thread-safe.",
        "If your UDF stores shared state that changes, then your code must be prepared to handle concurrent access to that state.\nThe next two sections provide more information about parallelism and shared state.",
        "To improve performance, Snowflake parallelizes both across and within JVMs.",
        "Across JVMs:",
        "Snowflake parallelizes across workers in a warehouse. Each worker runs one (or more)\nJVMs. This means that there is no global shared state. At most, state can be shared only within a single JVM.",
        "Within JVMs:",
        "Each JVM can execute multiple threads that can call the same instance\u2019s handler method in parallel. This means that each\nhandler method needs to be thread-safe.",
        "If a UDF is IMMUTABLE and a SQL statement calls the UDF more than once with the same arguments for the same row, then the UDF\nreturns the same value for each call for that row. For example, the following returns the same value twice for each row\nif the UDF is IMMUTABLE:",
        "If you would like multiple calls to return independent values even when passed the same arguments, and if you do not want\nto declare the function VOLATILE, then bind multiple separate UDFs to the same handler method. For example:",
        "Create a JAR file named @java_udf_stage/rand.jar with code:",
        "Create the Java UDFs as shown below. These UDFs have different names, but use the same JAR file and the same handler\nwithin that JAR file.",
        "The following code calls both UDFs. The UDFs point to the same JAR file and handler. These calls create two\ninstances of the same class. Each instance returns an independent value, so the example below returns two independent\nvalues, rather than returning the same value twice:",
        "One reason to avoid relying on dynamic shared state is that rows are not necessarily processed in a predictable order.\nEach time a SQL statement is executed, Snowflake can vary the number of batches, the order in which batches are\nprocessed, and the order of rows within a batch. If a scalar UDF is designed so that one row affects the return value for a\nsubsequent row, then the UDF can return different results each time that the UDF is executed.",
        "A Java method used as a UDF can use the normal Java exception-handling techniques to catch errors within the\nmethod.",
        "If an exception occurs inside the method and is not caught by the method, Snowflake raises an error that includes the stack trace for the\nexception. When logging of unhandled exceptions is enabled,\nSnowflake logs data about unhandled exceptions in an event table.",
        "You can explicitly throw an exception without catching it in order to end the query and produce a SQL error. For\nexample:",
        "When debugging, you can include values in the SQL error message text. To do so, place an entire Java method body in a\ntry-catch block; append argument values to the caught error\u2019s message; and throw an exception with the extended\nmessage. To avoid revealing sensitive data, remove argument values prior to deploying JAR files to a production\nenvironment.",
        "Write platform-independent code.",
        "Avoid code that assumes a specific CPU architecture (e.g. x86).",
        "Avoid code that assumes a specific operating system.",
        "If you need to execute initialization code and do not want to include it in the method that you call, you can put\nthe initialization code into a static initialization block.",
        "Whenever possible when using an in-line handler, specify a value for the CREATE FUNCTION or\nCREATE PROCEDURE TARGET_PATH parameter. This will prompt Snowflake to reuse previously-generated\nhandler code output rather than recompiling for each call. For more information, see Using an in-line handler.",
        "See also:",
        "Designing Handlers that Stay Within Snowflake-Imposed Constraints",
        "Security Practices for UDFs and Procedures",
        "To help ensure that your handler functions in a secure way, see the best practices described in\nSecurity Practices for UDFs and Procedures.",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}