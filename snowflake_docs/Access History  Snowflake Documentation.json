{
    "url": "https://docs.snowflake.com/en/user-guide/access-history",
    "title": "Access History | Snowflake Documentation",
    "paragraphs": [
        "Enterprise Edition Feature",
        "Access History requires Enterprise Edition (or higher). To inquire about upgrading, please contact\nSnowflake Support.",
        "This topic provides concepts on the user access history in Snowflake.",
        "Access History in Snowflake refers to when the user query reads data and when the SQL statement performs a data write\noperation, such as INSERT, UPDATE, and DELETE along with variations of the COPY command, from the source data object to the target data\nobject. The user access history can be found by querying the ACCESS_HISTORY view in the ACCOUNT_USAGE and ORGANIZATION_USAGE schemas. The\nrecords in these views facilitate regulatory compliance auditing and provide insights on popular and frequently accessed tables and columns\nbecause there is a direct link between the user (i.e. query operator), the query, the table or view, the column, and the data.",
        "Each row in the ACCESS_HISTORY view contains a single record per SQL statement. The record contains the following kinds of information:",
        "The source columns the query accessed directly and indirectly, such as the underlying tables that the data for the query comes from.",
        "The projected columns the user sees in the query result, such as the columns specified in a SELECT statement.",
        "The columns that are used to determine the query result but are not projected, such as columns in a WHERE clause to filter the result.",
        "For example:",
        "Columns C1 and C2 are source columns that the view accesses directly, which are recorded in the base_objects_accessed column of\nthe ACCESS_HISTORY view.",
        "Column C3 is used to filter the rows the view includes, which is recorded in the base_objects_accessed column of\nthe ACCESS_HISTORY view.",
        "Columns VC1 and VC2 are projected columns the user sees when querying the view, SELECT * FROM v1;, which are recorded in the\ndirect_objects_accessed column of the ACCESS_HISTORY view.",
        "The same behavior applies to a key column in a WHERE clause. For example:",
        "Two different tables are required to create the view: bt (base table) and jt (join table.).",
        "Columns C1, C2, and C3 from the base table and column C1 from the join table are all recorded in the base_objects_accessed column\nof the ACCESS_HISTORY view.",
        "Columns VC1, VC2, and C1 are projected columns the user sees when querying the view, SELECT * FROM join_v;, which are\nrecorded in the direct_objects_accessed column of the ACCESS_HISTORY view.",
        "Note",
        "Records in the Account Usage QUERY_HISTORY view do not always get recorded in the\nACCESS_HISTORY view. The structure of the SQL statement determines whether Snowflake records an entry in the ACCESS_HISTORY view.",
        "For details on the read and write operations Snowflake supports in the ACCESS_HISTORY view, refer to the view\nUsage notes.",
        "The ACCESS_HISTORY view in both the ACCOUNT_USAGE and the ORGANIZATION_USAGE schemas includes the following columns:",
        "Read operations are tracked through the first five columns, while the last column,\nobjects_modified, specifies the data write information that involved Snowflake columns, tables, and stages.",
        "The query in Snowflake and how the database objects were created determines the information Snowflake returns in the\ndirect_objects_accessed, base_objects_accessed, and objects_modified columns.",
        "Similarly, if the query references an object protected by a row access policy or a column protected by a masking policy, Snowflake records\nthe policy information in the policies_referenced column.",
        "The object_modified_by_ddl column records the DDL operation on a database, schema, table, view, and column. These operations also\ninclude statements that specify a row access policy on a table or view, a masking policy on a column, and tag updates\n(e.g. set a tag, change a tag value) on the object or column.",
        "The parent_query_id and root_query_id columns record query IDs that correspond to:",
        "A query that performs a read or write operation on another object.",
        "A query that performs a read or write operation on an object that calls a stored procedure, including nested stored procedure calls. For\ndetails, see ancestor queries (in this topic).",
        "For column details, see the Columns section in the ACCESS_HISTORY view.",
        "Consider the following scenario to understand a read query and how the ACCESS_HISTORY view records this information:",
        "A series of objects: base_table \u00bb view_1 \u00bb view_2 \u00bb view_3.",
        "A read query on view_2, such as:",
        "In this example, Snowflake returns:",
        "view_2 in the direct_objects_accessed column because the query specifies view_2.",
        "base_table in the base_objects_accessed column because that is the original source of the data in view_2.",
        "Note that view_1 and view_3 are not included in the direct_objects_accessed and base_objects_accessed columns\nbecause neither of those views were included in the query and they are not the base object that serves as the source for the data in\nview_2.",
        "Consider the following scenario to understand a write operation and how the ACCESS_HISTORY view records this information:",
        "A data source: base_table",
        "Create a table from the data source (i.e. CTAS):",
        "In this example, Snowflake returns:",
        "base_table in the base_objects_accessed and direct_objects_accessed columns because the table was accessed directly\nand is the source of the data.",
        "table_1 in the objects_modified column with the columns that were written to when creating the table.",
        "For a complete description of the read and write operations the ACCESS_HISTORY view supports, see the usage notes sections in the\nACCESS_HISTORY view.",
        "Snowflake supports executing multiple statements simultaneously as a single request. How you track the request in the access history depends\non whether it was executed in Snowsight or programmatically.",
        "When you use Snowsight to execute multiple statements, it runs the queries one at a time and returns the\nquery_id of the last executed query. You can find all executed statements and their return values in the ACCESS_HISTORY view.",
        "Features like the Snowflake Python connector or the Snowflake SQL API combine multiple SQL statements into a single request and return a\nsingle query_id for all of the statements. This number is actually a parent query id for all of the individual\nstatements. To return the query_id of each statement that comprised the request, you must query the ACCESS_HISTORY view using the\nparent_query_id. For example, if the request returned query_id = 6789, then you can return the query ids of the individual\nstatements by executing the following:",
        "Access history in Snowflake provides the following benefits pertaining to read and write operations:",
        "Discover unused data to determine whether to archive or delete the data.",
        "Track data movement from an external cloud storage location (e.g. Amazon S3 bucket) to the target Snowflake table, and vice versa.",
        "Track internal data movement from a Snowflake table to a different Snowflake table.",
        "After tracing the movement of sensitive data, apply policies (masking and\nrow access) to protect data, update\naccess control settings to further regulate access to the stage and table, and set\ntags to ensure stages, tables, and columns with sensitive data can be tracked for compliance\nrequirements.",
        "The accuracy and integrity of reports, dashboards, and data visualization products such as charts and graphs are validated since the\ndata can be traced to its original source.",
        "Data stewards can also notify users prior to dropping or altering a given table or view.",
        "Identify the Snowflake user who performed a write operation on a table or stage and when the write operation occurred to meet compliance\nregulations, such as GDPR and CCPA.",
        "The ACCESS_HISTORY view provides a unified picture of what data was accessed, when the data access took place, and how the accessed data\nmoved from the data source object to the data target object.",
        "Column lineage (i.e. access history for columns) extends the Account Usage ACCESS_HISTORY view to specify how data flows from the source\ncolumn to the target column in a write operation. Snowflake tracks the data from the source columns through all subsequent table objects\nthat reference data from the source columns (e.g. INSERT, MERGE, CTAS) provided that objects in the lineage chain are not dropped.\nSnowflake makes column lineage accessible by enhancing the objects_modified column in the ACCESS_HISTORY view.",
        "Column lineage provides the following benefits:",
        "Data stewards can easily tag sensitive source columns without having to do additional work after\ncreating derived objects (e.g. CTAS). Subsequently, the data steward can protect tables containing sensitive columns with a\nrow access policy or protect the sensitive columns themselves with either a\nmasking policy or a\ntag-based masking policy.",
        "Data privacy officers can quickly determine the object count (e.g. 1 table, 2 views) of a column containing sensitive data. By knowing\nhow many times a column with sensitive data appears in a table object, data privacy officers can prove how they satisfy regulatory\ncompliance standards (e.g. to meet General Data Protection Regulation (GDPR) standards in the European Union).",
        "Column lineage provides a mechanism to trace the data to its source, which can help to pinpoint points of failure resulting from\npoor data quality and reduce the number of columns to analyze during the troubleshooting process.",
        "For additional details about column lineage, see:",
        "Example: Column lineage (in this topic)",
        "Column Lineage Usage Notes",
        "The POLICY_REFERENCED column specifies the object that has a row access policy set on a table or a masking policy set on a column,\nincluding any intermediate objects that are protected by either a row access policy or a masking policy. Snowflake records the policy that\nis enforced on the table or column.",
        "Consider these objects:",
        "t1 \u00bb v1 \u00bb v2",
        "Where:",
        "t1 is a base table.",
        "v1 is a view built from the base table.",
        "v2 is a view built from v1.",
        "If the user queries v2, the policies_referenced column records either the row access policy that protects v2, each masking\npolicy that protects the columns in v2, or both kinds of policy as applicable. Additionally, this column records any masking or row\naccess policies that protect t1 and v1.",
        "These records can help data governors understand how their policy-protected objects are accessed.",
        "The policies_referenced column provides additional benefits to the ACCESS_HISTORY view:",
        "Identify the policy-protected objects a user accesses in a given query.",
        "Simplify the policy audit process.",
        "Querying the ACCESS_HISTORY view eliminates the need for complex joins on other Account Usage views\n(e.g. POLICY_REFERENCES and\nQUERY_HISTORY), to obtain information about the protected objects and protected\ncolumns a user accesses.",
        "Administrators monitor access history at the account-level by querying the\nACCESS_HISTORY view in the account\u2019s ACCOUNT_USAGE schema. There\nis no additional cost associated with the ACCOUNT_USAGE.ACCESS_HISTORY view.",
        "The ACCESS_HISTORY view in the ORGANIZATION_USAGE schema gathers the access history of all of the accounts in an organization into a single\nview to provide an organization-level access history. This ORGANIZATION_USAGE.ACCESS_HISTORY view is only found in the\norganization account.",
        "Organization-level access history in the ORGANIZATION_USAGE schema differs from access history in the ACCOUNT_USAGE schema in the\nfollowing ways:",
        "The ORGANIZATION_USAGE.ACCESS_HISTORY view in the organization account contains additional columns that provide insights related to\norganizational listings. These columns can be used to determine which of\nthe data products attached to an organization listing were accessed by a consumer\u2019s query, and whether those data products are protected\nby a policy such as a masking policy. For more information, see Organizational listing governance.",
        "The ORGANIZATION_USAGE.ACCESS_HISTORY view in the organization account is a premium view that incurs the following costs:",
        "Compute costs associated with the serverless tasks that populate the ACCESS_HISTORY view.",
        "Storage costs associated with storing the data in the ACCESS_HISTORY view.",
        "For more information about these costs, see Costs associated with the ORGANIZATION_USAGE schema.",
        "The following sections provide example queries for the ACCESS_HISTORY view.",
        "Note that some of the example queries filter on the query_start_time column to increase query performance. Another option to\nincrease performance is to query over narrower time ranges.",
        "The subsections below detail how to query the ACCESS_HISTORY view for read operations for the following use cases:",
        "Obtain the access history for a specific user.",
        "Facilitate compliance audits for sensitive data access in the last 30 days, based on object_id (e.g. a table id), to answer the\nfollowing questions:",
        "Who accessed the data?",
        "When was the data accessed?",
        "What columns were accessed?",
        "Return the user access history, ordered by user and query start time, starting from the most recent access.",
        "The following examples help to facilitate compliance audits:",
        "Add the object_id value to determine who accessed a sensitive table in the last 30 days:",
        "Using the object_id value of 32998411400350, determine when the access occurred in the last 30 days:",
        "Using the object_id value of 32998411400350, determine which columns were accessed in the last 30 days:",
        "The subsections below detail how to query the ACCESS_HISTORY view for write operations for the following use cases:",
        "Load data from a stage to a table.",
        "Unload data from a table to a stage.",
        "Use the PUT command to upload a local file to a stage.",
        "Use the GET command to retrieve data files from a stage to a local directory.",
        "Tracking sensitive stage data movement.",
        "Load a set of values from a data file in external cloud storage into columns in a target table.",
        "The direct_objects_accessed and base_objects_accessed column specify that an external named stage was accessed:",
        "The objects_modified column specifies that data was written to two columns of the table:",
        "Unload a set of values from a Snowflake table into cloud storage.",
        "The direct_objects_accessed and base_objects_accessed columns specify the table columns that were\naccessed:",
        "The objects_modified column specifies the stage to which the accessed data was written:",
        "Copy a data file to an internal (i.e. Snowflake) stage.",
        "The direct_objects_accessed and base_objects_accessed columns specify the local path to the file that was\naccessed:",
        "The objects_modified column specifies the stage where the accessed data was written:",
        "Retrieve a data file from an internal stage to a directory on the local machine.",
        "The direct_objects_accessed and base_objects_accessed columns specify the stage and local directory that were\naccessed:",
        "The objects_modified column specifies the directory to which the accessed data was written:",
        "Track sensitive stage data as it moves through a series of queries executed in chronological order.",
        "Execute the following queries. Note that five of the statements access stage data. Therefore, when you query the ACCESS_HISTORY view for\nstage access, the result set should include five rows.",
        "Where:",
        "T1, T2 \u2026 T7 specify the names of tables.",
        "S1 and S2 specify the names of stages.",
        "Query the access history to determine the access to stage S1.",
        "The data for the direct_objects_accessed, base_objects_accessed, and objects_modified columns are shown in the\nfollowing table.",
        "direct_objects_accessed",
        "base_objects_accessed",
        "objects_modified",
        "Note the following about the query example:",
        "Uses a recursive common table expression.",
        "Uses a JOIN construct rather than a\nUSING clause.",
        "The query produces the following result set related to stage S1 data movement:",
        "PATH",
        "TARGET_NAME",
        "TARGET_ID",
        "TARGET_DOMAIN",
        "TARGET_COLUMNS",
        "TEST_DB.TEST_SCHEMA.S1\u2013>TEST_DB.TEST_SCHEMA.T1",
        "TEST_DB.TEST_SCHEMA.T1",
        "66564",
        "Table",
        "[\u201cCONTENT\u201d]",
        "TEST_DB.TEST_SCHEMA.S1\u2013>TEST_DB.TEST_SCHEMA.T1\u2013>TEST_DB.TEST_SCHEMA.S2",
        "TEST_DB.TEST_SCHEMA.S2",
        "118",
        "Stage",
        "[]",
        "TEST_DB.TEST_SCHEMA.S1\u2013>TEST_DB.TEST_SCHEMA.T1\u2013>TEST_DB.TEST_SCHEMA.T2",
        "TEST_DB.TEST_SCHEMA.T2",
        "66568",
        "Table",
        "[\u201cNAME\u201d,\u201dID\u201d]",
        "TEST_DB.TEST_SCHEMA.S1\u2013>TEST_DB.TEST_SCHEMA.T1\u2013>TEST_DB.TEST_SCHEMA.T4",
        "TEST_DB.TEST_SCHEMA.T4",
        "66572",
        "Table",
        "[\u201cID\u201d,\u201dNAME\u201d]",
        "TEST_DB.TEST_SCHEMA.S1\u2013>TEST_DB.TEST_SCHEMA.T3",
        "TEST_DB.TEST_SCHEMA.T3",
        "66570",
        "Table",
        "[\u201cCUSTOMER_INFO\u201d]",
        "The following example queries the ACCESS_HISTORY view and uses the FLATTEN function to flatten the\nobjects_modified column.",
        "As a representative example, execute the following SQL query in your Snowflake account to produce the table below, where the numbered\ncomments indicate the following:",
        "// 1: Get the mapping between the directSources field and the target column.",
        "// 2: Get the mapping between the baseSources field and the target column.",
        "Returns:",
        "SOURCE_OBJECT_ID",
        "SOURCE_OBJECT_NAME",
        "SOURCE_COLUMN_NAME",
        "SOURCE_COLUMN_TYPE",
        "TARGET_OBJECT_NAME",
        "TARGET_COLUMN_NAME",
        "1",
        "D.S.T0",
        "NAME",
        "BASE",
        "D.S.T1",
        "NAME",
        "2",
        "D.S.V1",
        "NAME",
        "DIRECT",
        "D.S.T1",
        "NAME",
        "Return a row for each instance when a row access policy is set on a table, view, or materialized view without duplicates:",
        "Return a row for each instance when a masking policy protects a column without duplicates. Note that additional flattening is necessary\nbecause the policies_referenced column specifies the masking policy on a column one level deeper than the row access policy on a\ntable:",
        "Return the time when the policy was updated (POLICY_CHANGED_TIME) and the policy conditions (POLICY_BODY) for a given query in a given time\nframe.",
        "Prior to using this query, update the WHERE clause input values:",
        "Where:",
        "Specifies the beginning timestamp.",
        "Specifies the end timestamp.",
        "Specifies the query identifier in the Account Usage ACCESS_HISTORY view.",
        "Run the query:",
        "These UDF examples show how the Account Usage ACCESS_HISTORY view records:",
        "Calling a UDF named get_product.",
        "Insert the product of calling the get_product function into a table named\nmydb.tables.t1.",
        "Shared UDFs.",
        "Consider the following SQL UDF that calculates the product of two numbers and assume it is stored in the schema named mydb.udfs:",
        "Calling get_product directly results in recording the UDF details in the\ndirect_objects_accessed column:",
        "This example is analogous to calling a stored procedure (in this topic).",
        "Consider the following INSERT statement to update the columns named 1 and 2 in the table named mydb.tables.t1:",
        "The ACCESS_HISTORY view records the get_product function in the:",
        "direct_objects_accessed column because the function is explicitly named in the SQL statement, and",
        "objects_modified column in the directSources array because the function is the source of the values that are inserted into\nthe columns.",
        "Similarly, the table t1 is recorded in these same columns:",
        "direct_objects_accessed",
        "objects_modified",
        "Shared UDFs can be referenced directly or indirectly:",
        "A direct reference is the same as calling the UDF explicitly (in this topic) but results\nin the UDF being recorded in both the base_objects_accessed and direct_objects_accessed columns.",
        "An example of an indirect reference is calling the UDF to create a view:",
        "The base_objects_accessed column records the UDF and the table.",
        "The direct_objects_accessed column records the view.",
        "Create the tag:",
        "Column value:",
        "Note",
        "If you do not specify allowed values when creating the tag, the properties field is an empty array (i.e. {}).",
        "Create the table with a masking policy on the column, a tag on the column, and a tag on the table:",
        "Column value:",
        "Set a masking policy on the tag (i.e. tag-based masking):",
        "Column value:",
        "Swap the table named t2 with the table named t3:",
        "Note the two different records in the view.",
        "Record 1:",
        "Record 2:",
        "Drop the masking policy:",
        "Column value:",
        "Note",
        "The column value is representative and applies to a DROP operation on a tag and row access policy.",
        "The properties field is an empty array and does not provide any information on the policy prior to the DROP operation.",
        "Query the object_modified_by_ddl column to monitor how a tag is set on a column.",
        "As the table administrator, set a tag on a column, unset the tag, and update the tag with a different string value:",
        "As the data engineer, change the tag value:",
        "Query the ACCESS_HISTORY view to monitor the changes:",
        "Returns:",
        "Consider the following stored procedure and assume it is stored in the schema named mydb.procedures:",
        "Calling my_procedure directly results in recording the procedure details in both the\ndirect_objects_accessed and base_objects_accessed columns as follows:",
        "This example is analogous to calling a UDF (in this topic).",
        "You can use the parent_query_id and root_query_id columns to understand how stored procedure calls relate to each other.",
        "Suppose that you have three different stored procedure statements and you run them in the following order:",
        "A query on the ACCESS_HISTORY view records the information as follows:",
        "The first row corresponds to calling the second procedure named myproc_parent as shown in the direct_objects_accessed\ncolumn.",
        "The parent_query_id and root_query_id columns return NULL because you called this stored procedure directly.",
        "The second row corresponds to the query that calls the first procedure named myproc_child as shown in the\ndirect_objects_accessed column.",
        "The parent_query_id and root_query_id columns return the same query ID because the query calling myproc_child was\ninitiated by the query calling myproc_parent, which you called directly.",
        "The third row corresponds to the query that accessed the table named mytable in the myproc_child procedure as shown in\nthe direct_objects_accessed column.",
        "The parent_query_id column returns the query ID of the query that accessed mytable, which corresponds to calling\nmyproc_child. That stored procedure was initiated by the query calling myproc_parent, which is shown in the\nroot_query_id column.",
        "Consider the following SQL statement that creates a sequence:",
        "Creating this sequence results in the following entry in the access history:",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}