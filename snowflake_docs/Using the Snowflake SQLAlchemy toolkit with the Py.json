{
    "url": "https://docs.snowflake.com/en/developer-guide/python-connector/sqlalchemy",
    "title": "Using the Snowflake SQLAlchemy toolkit with the Python Connector | Snowflake Documentation",
    "paragraphs": [
        "Snowflake SQLAlchemy runs on the top of the Snowflake Connector for Python as a dialect to bridge a Snowflake database and SQLAlchemy applications.",
        "For more information, see the dialect documentation.",
        "The only requirement for Snowflake SQLAlchemy is the Snowflake Connector for Python; however, the connector does not need to be installed because installing Snowflake SQLAlchemy automatically installs\nthe connector.",
        "Snowflake SQLAlchemy can be used with pandas, Jupyter, and Pyramid, which provide higher levels of application\nframeworks for data analytics and web applications. However, building a working environment from scratch is not a trivial task, particularly for novice users. Installing the frameworks requires\nC compilers and tools, and choosing the right tools and versions is a hurdle that might deter users from using Python applications.",
        "An easier way to build an environment is through Anaconda, which provides a complete, precompiled technology stack for all users, including non-Python experts\nsuch as data analysts and students. For Anaconda installation instructions, see the Anaconda install documentation. The Snowflake SQLAlchemy package can\nthen be installed on top of Anaconda using pip.",
        "For more information, see the following documentation:",
        "pandas",
        "Jupyter",
        "Pyramid",
        "Anaconda",
        "Anaconda install",
        "pip",
        "The Snowflake SQLAlchemy package can be installed from the public PyPI repository using pip:",
        "pip automatically installs all required modules, including the Snowflake Connector for Python.",
        "Note that the developer notes are hosted with the source code on GitHub.",
        "Create a file (e.g. validate.py) that contains the following Python sample code,\nwhich connects to Snowflake and displays the Snowflake version:",
        "Replace <user_login_name>, <password>, and <account_identifier> with the appropriate values for your Snowflake account and user. For more details, see\nConnection Parameters (in this topic).",
        "Execute the sample code. For example, if you created a file named validate.py:",
        "The Snowflake version (e.g. 1.6.0) should be displayed.",
        "As much as possible, Snowflake SQLAlchemy provides compatible functionality for SQLAlchemy applications.",
        "For information on using SQLAlchemy, see the SQLAlchemy documentation.",
        "However, Snowflake SQLAlchemy also provides Snowflake-specific parameters and behavior, which are described in the following sections.",
        "Snowflake SQLAlchemy uses the following connection string syntax to connect to Snowflake and initiate a session:",
        "Where:",
        "<user_login_name> is the login name for your Snowflake user.",
        "<password> is the password for your Snowflake user.",
        "<account_identifier> is your account identifier. See Configuring a client, driver, library, or third-party application to connect to Snowflake.",
        "Note",
        "Do not include the snowflakecomputing.com domain name as part of your account identifier. Snowflake\nautomatically appends the domain name to your account identifier to create the required connection.",
        "You can optionally include the following additional information at the end of the connection string (after <account_name>):",
        "Where:",
        "<database_name> and <schema_name> are the initial database and schema for the Snowflake session, separated by forward slashes (/).",
        "warehouse=<warehouse_name> and role=<role_name>' are the initial warehouse and role for the session, specified as parameter strings, separated by question marks (?).",
        "Note",
        "After login, the initial database, schema, warehouse, and role specified in the connection string can always be changed for the session.",
        "Proxy server parameters are not supported. Instead, use the supported environment variables to configure a proxy server. For information, see Using a proxy server.",
        "The following example calls the create_engine method with the user name testuser1, password 0123456, account\nidentifier myorganization-myaccount, database testdb, schema public, warehouse testwh, and role myrole:",
        "For convenience, you can use the snowflake.sqlalchemy.URL method to construct the connection string and connect to the database. The following example constructs the same connection string\nfrom the previous example:",
        "Open a connection by executing engine.connect(); avoid using engine.execute().",
        "Note",
        "Make certain to close the connection by executing connection.close() before engine.dispose(); otherwise, the Python Garbage collector removes the resources required to communicate\nwith Snowflake, preventing the Python connector from closing the session properly.",
        "If you plan to use explicit transactions, you must disable the AUTOCOMMIT execution option in SQLAlchemy.",
        "For more information, see AUTOCOMMIT execution option in SQLAlchemy..",
        "By default, SQLAlchemy enables this option. When this option is enabled, INSERT, UPDATE, and DELETE statements are committed\nautomatically upon execution, even when these statements are run within an explicit transaction.",
        "To disable AUTOCOMMIT, pass autocommit=False to the Connection.execution_options() method. For example:",
        "Auto-incrementing a value requires the Sequence object. Include the Sequence object in the primary key column to automatically increment the value as each new record is inserted.\nFor example:",
        "Snowflake stores all case-insensitive object names in uppercase text. In contrast, SQLAlchemy considers all lowercase object names to be case-insensitive. Snowflake SQLAlchemy converts the object\nname case during schema-level communication (i.e. during table and index reflection). If you use uppercase object names, SQLAlchemy assumes they are case-sensitive and encloses the names with quotes.\nThis behavior will cause mismatches against data dictionary data received from Snowflake, so unless identifier names have been truly created as case sensitive using quotes (e.g. \"TestDb\"),\nall lowercase names should be used on the SQLAlchemy side.",
        "Indexes are supported only for Hybrid Tables in Snowflake SqlAlchemy. For more details on limitations and use cases, refer to Create Index documentation. You can create an index using the following methods:",
        "Single column index",
        "You can create a single column index by setting the index=True parameter on the column or by explicitly defining an Index object.",
        "Multi-column index",
        "For multi-column indexes, you define the Index object specifying the columns that should be indexed.",
        "Snowflake SQLAlchemy supports binding and fetching NumPy data types. Binding is always supported. To enable fetching NumPy data types, add numpy=True to the connection\nparameters.",
        "The following NumPy data types are supported:",
        "numpy.int64",
        "numpy.float64",
        "numpy.datetime64",
        "The following example shows the round trip of numpy.datetime64 data:",
        "SQLAlchemy provides the runtime inspection API to get the runtime information about the various objects. One of the common use case\nis get all tables and their column metadata in a schema in order to construct a schema catalog.",
        "For more information, see runtime inspection API. For an example managing database schema migrations with SQLAlchemy, alembic .",
        "A pseudo code flow is as follows:",
        "In this flow, a potential problem is it may take quite a while as queries run on each table. The results are cached but getting column metadata is expensive.",
        "To mitigate the problem, Snowflake SQLAlchemy takes a flag cache_column_metadata=True such that all of column metadata for all tables are cached when get_table_names is called and\nthe rest of get_columns, get_primary_keys and get_foreign_keys can take advantage of the cache.",
        "Note",
        "Memory usage will go up higher as all of column metadata are cached associated with Inspector object. Use the flag only if you need to get all of column metadata.",
        "Snowflake SQLAlchemy supports fetching VARIANT, ARRAY and OBJECT data types. All types are converted into str in Python so that you can convert them to native data\ntypes using json.loads.",
        "This example shows how to create a table including VARIANT, ARRAY, and OBJECT data type columns:",
        "In order to retrieve VARIANT, ARRAY, and OBJECT data type columns and convert them to the native Python data types, fetch data and call the json.loads method as follows:",
        "This module defines custom SQLAlchemy types for Snowflake structured data, specifically for Iceberg tables. The MAP, OBJECT, and ARRAY types allow you to store complex data structures in your SQLAlchemy models. For detailed information, refer to the Snowflake Structured data types documentation.",
        "The MAP type represents a collection of key-value pairs, where each key and value can have different types, as shown:",
        "Key Type: The type of the key, such as TEXT or NUMBER).",
        "Value Type: The type of the value, such as  TEXT or NUMBER).",
        "Not Null: Whether NULL values are allowed (default is False).",
        "Usage example:",
        "The OBJECT type represents a semi-structured object with named fields. Each field can have a specific type, and you can also specify whether each field is nullable.",
        "Items Types: A dictionary of field names and their types. The type can optionally include a nullable flag (True for not nullable or False for nullable [default]).",
        "Usage example:",
        "The ARRAY type represents an ordered list of values, where each element has the same type. The type of the elements is defined when the array is created.",
        "Value Type: The type of the elements in the array, such as TEXT or NUMBER).",
        "Not Null: Whether NULL values are allowed (default is False).",
        "Usage example:",
        "Snowflake SQLAlchemy supports the CLUSTER BY parameter for tables. For information about the parameter, see CREATE TABLE.",
        "This example shows how to create a table with two columns, id and name, as the clustering key:",
        "Alembic is a database migration tool on top of SQLAlchemy. Snowflake SQLAlchemy works by adding the following code to alembic/env.py so that Alembic can  recognize Snowflake SQLAlchemy.",
        "See Alembic Documentation for general usage.",
        "Snowflake SQLAlchemy supports key pair authentication by leveraging the functionality of Snowflake Connector for Python.\nSee Using key-pair authentication and key-pair rotation for steps to create the private and public keys.",
        "The private key parameter is passed through connect_args as follows:",
        "Where PRIVATE_KEY_PASSPHRASE is a passphrase to decrypt the private key file, rsa_key.p8.",
        "The snowflake.sqlalchemy.URL method does not support private key parameters.",
        "Snowflake SQLAlchemy supports performing an upsert with its MergeInto custom expression. See MERGE for full documentation.",
        "Use it as follows:",
        "Snowflake SQLAlchemy supports saving tables and query results into different Snowflake stages, Azure Containers, and AWS buckets with\nits custom CopyIntoStorage expression. See COPY INTO <location> for full documentation.",
        "Use it as follows:",
        "Snowflake SQLAlchemy supports Iceberg Tables with the Snowflake Catalog, along with various related parameters. For detailed information about Iceberg Tables, refer to the Snowflake CREATE ICEBERG documentation.",
        "To create an Iceberg Table using Snowflake SQLAlchemy, you can define the table using the SQLAlchemy Core syntax as follows:",
        "Alternatively, you can define the table using a declarative approach:",
        "Snowflake SQLAlchemy supports Hybrid Tables with indexes. For detailed information refer to the Snowflake CREATE HYBRID TABLE documentation.",
        "To create a Hybrid Table and add an index, you can use the SQLAlchemy Core syntax as follows:",
        "Alternatively, you can define the table using the declarative approach:",
        "Snowflake SQLAlchemy supports Dynamic Tables. For detailed information refer to the Snowflake CREATE DYNAMIC TABLE documentation.",
        "To create a Dynamic Table, you can use the SQLAlchemy Core syntax as follows:",
        "Additionally you can define a table without columns using SqlAlchemy select() construct:",
        "Note",
        "Defining a primary key in a Dynamic Table is not supported, meaning declarative tables don\u2019t support Dynamic Tables.",
        "When using the as_query parameter with a string, you must explicitly define the columns. However, if you use the SQLAlchemy select() construct, you don\u2019t need to explicitly define the columns.",
        "Direct data insertion into Dynamic Tables is not supported.",
        "Was this page helpful?",
        "On this page"
    ]
}