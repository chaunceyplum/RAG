{
    "url": "https://docs.snowflake.com/en/sql-reference/functions/search",
    "title": "SEARCH | Snowflake Documentation",
    "paragraphs": [
        "String & binary functions (Full-Text Search)",
        "Searches character data (text) in specified columns from one or more tables, including fields in VARIANT, OBJECT,\nand ARRAY columns. A text analyzer breaks the text into tokens, which are discrete units of text, such as words\nor numbers. A default analyzer is applied if you do not specify one.",
        "For more information about using this function, see Using full-text search.",
        "The data you want to search, expressed as a comma-delimited list of string literals, column names, or\npaths to fields in VARIANT columns. The search data can\nalso be a single literal string, which can be useful when you are testing the function.",
        "You can specify the wildcard character (*), where * expands to all qualifying columns in all of the\ntables that are in scope for the function. Qualifying columns are those that have VARCHAR (text), VARIANT,\nARRAY, and OBJECT data types. VARIANT, ARRAY, and OBJECT data is converted to text for searching.",
        "When you pass a wildcard to the function, you can qualify the wildcard with the name or alias for the table.\nFor example, to pass in all of the columns from the table named mytable, specify the following:",
        "You can also use the ILIKE and EXCLUDE keywords for filtering:",
        "ILIKE filters for column names that match the specified pattern. Only one\npattern is allowed. For example:",
        "EXCLUDE filters out column names that don\u2019t match the specified column or columns. For example:",
        "Qualifiers are valid when you use these keywords. The following example uses the ILIKE keyword to\nfilter for all of the columns that match the pattern col1% in the table mytable:",
        "The ILIKE and EXCLUDE keywords can\u2019t be combined in a single function call.",
        "For more information about the ILIKE and EXCLUDE keywords, see the \u201cParameters\u201d section in SELECT.",
        "You can search columns from more than one table when multiple tables are in scope by joining tables or using\nthe UNION set operator. To search all of the columns in the output of a\njoin or a UNION query, you can use the unqualified * wildcard as follows:",
        "To search specific columns when joining tables, you might need to qualify the column\nnames (for example, table2.colname). You can also use a qualified * wildcard as follows:",
        "However, note that you cannot specify * or table.* more than once for the function.\nIn the previous join example, you could not specify SEARCH((T1.*, T2.*), 'string'). This\nsyntax returns an error.",
        "Parentheses are required for the search_data argument when *, table.*,\nor multiple items are listed. For example:",
        "If parentheses are not used to separate multiple items, commas are parsed as separators between function arguments.",
        "See also Examples of Expected Error Cases.",
        "You can search fields in VARIANT data by specifying the column name, a colon or dot, and the subfields\nseparated by dots. For example: colname:fieldname.subfieldname. For more information about specifying\nfields in such columns, see Traversing Semi-structured Data.",
        "A VARCHAR string that contains one or more search terms. This argument must be a literal string; column names\nare not supported. Specify one pair of single quotes around the entire string. Do not specify quotes around\nindividual terms or phrases. For example, use:",
        "'blue red green'",
        "Do not use:",
        "'blue' 'red' 'green'",
        "The list of terms is disjunctive. In this case, the search would look for rows that contain blue OR red\nOR green. However, when the NO_OP_ANALYZER is used, the query string is matched exactly as it is, with no\ntokenization and no disjunctive semantics.",
        "Searches are not case sensitive (except when the NO_OP_ANALYZER is used), so a search for the term 'ONCE'\nagainst the string 'Once upon a time' returns TRUE.",
        "The order of search terms does not matter, with respect to their presence in the searched data.",
        "Optional argument that specifies the name of the text analyzer. The name must be enclosed in single quotes.",
        "The analyzer breaks the search terms (and the text from the column being searched) into tokens.\nA row matches if any of the tokens extracted from the search string exactly matches a token\nextracted from any of the columns or fields being searched.",
        "The analyzer tokenizes a string by breaking it where it finds certain delimiters. These delimiters are not\nincluded in the resulting tokens, and empty tokens are not extracted.",
        "This parameter accepts one of the following values:",
        "DEFAULT_ANALYZER: Breaks text into tokens based on the following delimiters:",
        "Character",
        "Unicode code",
        "Description",
        "",
        "U+0020",
        "Space",
        "[",
        "U+005B",
        "Left square bracket",
        "]",
        "U+005D",
        "Right square bracket",
        ";",
        "U+003B",
        "Semicolon",
        "<",
        "U+003C",
        "Less-than sign",
        ">",
        "U+003E",
        "Greater-than sign",
        "(",
        "U+0028",
        "Left parenthesis",
        ")",
        "U+0029",
        "Right parenthesis",
        "{",
        "U+007B",
        "Left curly bracket",
        "}",
        "U+007D",
        "Right curly bracket",
        "|",
        "U+007C",
        "Vertical bar",
        "!",
        "U+0021",
        "Exclamation mark",
        ",",
        "U+002C",
        "Comma",
        "'",
        "U+0027",
        "Apostrophe",
        "\"",
        "U+0022",
        "Quotation mark",
        "*",
        "U+002A",
        "Asterisk",
        "&",
        "U+0026",
        "Ampersand",
        "?",
        "U+003F",
        "Question mark",
        "+",
        "U+002B",
        "Plus sign",
        "/",
        "U+002F",
        "Slash",
        ":",
        "U+003A",
        "Colon",
        "=",
        "U+003D",
        "Equal sign",
        "@",
        "U+0040",
        "At sign",
        ".",
        "U+002E",
        "Period (full stop)",
        "-",
        "U+002D",
        "Hyphen",
        "$",
        "U+0024",
        "Dollar sign",
        "%",
        "U+0025",
        "Percent sign",
        "\\",
        "U+005C",
        "Backslash",
        "_",
        "U+005F",
        "Underscore (low line)",
        "\\n",
        "U+000A",
        "New line (line feed)",
        "\\r",
        "U+000D",
        "Carriage return",
        "\\t",
        "U+0009",
        "Horizontal tab",
        "UNICODE_ANALYZER: Tokenizes based on Unicode segmentation rules that treat spaces and certain\npunctuation characters as delimiters. These internal rules are designed for natural language searches (in\nmany different languages). For example, the default analyzer treats periods in IP addresses and\napostrophes in contractions as delimiters, but the Unicode analyzer does not.\nSee Using an analyzer to adjust search behavior.",
        "For more information about the Unicode Text Segmentation algorithm, see https://unicode.org/reports/tr29/.",
        "NO_OP_ANALYZER: Tokenizes neither the data nor the query string. A search term must exactly match the full text\nin a column or field, including case sensitivity; otherwise, the SEARCH function returns FALSE. Even if the query\nstring looks like it contains multiple tokens (for example, 'sky blue'), the column or field must equal the\nentire query string exactly. In this case, only 'sky blue' is a match; 'sky' and 'blue' are not matches.",
        "For more information about the behavior of different analyzers, see How search terms are tokenized.",
        "Returns a BOOLEAN.",
        "The value is TRUE if any search_string tokens are found in search_data.",
        "Returns NULL if either of these arguments is NULL.",
        "Otherwise, returns FALSE.",
        "The SEARCH function operates only on VARCHAR, VARIANT, ARRAY, and OBJECT data. The function returns an error if the\nsearch_data argument doesn\u2019t contain data of these data types. When the search_data argument includes\ndata of both supported data types and unsupported data types, the function searches the data of the supported data\ntypes and silently ignores the data of the unsupported data types. For examples, see Examples of expected error cases.",
        "You can add a FULL_TEXT search optimization on columns that are the target of SEARCH function calls by using an ALTER TABLE\ncommand. For example:",
        "For more information, see enable FULL_TEXT search optimization.",
        "The following table shows a few examples of how input search terms are split into tokens,\nwhich depends on the rules applied by the analyzer that is used. In the table, commas\ndenote where the tokens are split (if they are).",
        "Search Term(s)",
        "Tokens: DEFAULT_ANALYZER",
        "Tokens: UNICODE_ANALYZER",
        "NO_OP_ANALYZER (not split)",
        "10.210.158.44",
        "10, 210, 158, 44",
        "10.210.158.44",
        "10.210.158.44",
        "192.0.2.0/24",
        "192, 0, 2, 24",
        "192.0.2.0, 24",
        "192.0.2.0/24",
        "high-tech",
        "high, tech",
        "high, tech",
        "high-tech",
        "Bob's Burgers",
        "bob, s, burgers",
        "bob's, burgers",
        "Bob's Burgers",
        "Three\u00a0\u00a0 spaces",
        "three, spaces",
        "three, spaces",
        "Three\u00a0\u00a0 spaces",
        "docs@snowflake.com",
        "docs, snowflake, com",
        "docs, snowflake.com",
        "docs@snowflake.com",
        "/opt/homebrew/README.md",
        "opt, homebrew, readme, md",
        "opt, homebrew, readme.md",
        "/opt/homebrew/README.md",
        "The following examples show different ways to use the SEARCH function, starting with simple\nusage and progressing to more complex use cases.",
        "The simplest example of the SEARCH function is a test for TRUE or FALSE on a string literal. The first\nexample returns TRUE because the literals for the first and second arguments match, given that the comparison\nis not case sensitive.",
        "The second example returns FALSE because the token 32 does not appear in the literal 5.1.33 specified\nfor the first argument.",
        "This example uses a column in a table as the first argument. The function returns TRUE because one of\nthe search terms (king) exists in the character column. The list of terms is disjunctive.\n(For information about the table used here and in some subsequent examples, see Sample data for SEARCH.)",
        "The following query uses the SEARCH function to find rows that contain the word \u201cwherefore\u201d in the line column:",
        "The following query uses the SEARCH function to find rows that contain the word \u201cking\u201d in the play column,\nthe character column, or both columns. Parentheses are required for the first argument.",
        "You can use the * character (or table.*) as the first argument to the SEARCH function, as shown in this example.\nThe search operates on all of the qualifying columns in the table you are selecting from, which in this case is the lines table.",
        "The lines table has four columns that have data types supported by the search function. Note that the result consists of rows where \u201cking\u201d\nappears in one or more of the four searched columns. For one of these columns, act_scene_line, the function finds no matches, but\nthe other three columns all have matches.",
        "You can also use the ILIKE and EXCLUDE keywords for filtering. For more information about\nthese keywords, see SELECT.",
        "This search uses the ILIKE keyword to search only in columns that end with the string line.",
        "This search uses the EXCLUDE keyword so that the function doesn\u2019t search the data in the character column.",
        "You can use the * character (or table.*) in a SELECT list, as shown in these examples.",
        "The following search operates on all of the qualifying columns in the table you are selecting from, which in\nthis case is the lines table. The search returns True when \u201cking\u201d appears in one or more of the four\nsearched columns.",
        "You can also use the ILIKE and EXCLUDE keywords for filtering. For more information about\nthese keywords, see SELECT.",
        "This search uses the ILIKE keyword to search only in columns that end with the string line.",
        "This search uses the EXCLUDE keyword so that the function doesn\u2019t search the data in the play or line columns.",
        "This example uses two small tables that contain information about car models. Table t1 has\ntwo character columns, and table t2 has three. You can create and load the tables as follows:",
        "The results of the following two queries differ, given the search over t1.* and t2.*.\nOnly two columns from t1 qualify for the search, but three columns from t2 qualify.",
        "The following example uses the same two tables as the previous example. In this case,\nthe search is applied to all qualifying columns from t3, which is the table that results\nfrom the subquery. The subquery computes the UNION of the first three columns in t1 and\nt2 (five rows). The search returns two matching rows from the UNION result.",
        "The following example shows how to use SEARCH twice in the same query, so that both\nsearch strings have to return TRUE in order for a row to qualify for the result.",
        "The following example shows a join of two tables, car_rentals and car_sales, with the search applied\nto columns in both tables. The car_sales table contains VARIANT data. The car_sales table and its data\nare described under Querying Semi-structured Data. The following SQL statements create the\ncar_rentals table and insert data into it:",
        "Run the query:",
        "In this second example, against the same data, different search terms are used:",
        "The following examples show how to adjust the behavior of the SEARCH function by specifying a\nnon-default analyzer: UNICODE_ANALYZER or NO_OP_ANALYZER.",
        "The first example uses the NO_OP_ANALYZER to test whether the string 1.2.500 matches the exact contents\nof the act_scene_line column for any row in the lines table. Two rows qualify for the search.",
        "If you remove NO_OP_ANALYZER as an argument to the function for this example, the search returns a large\nnumber of rows. The default analyzer treats 1, 2, and 500 as distinct tokens; therefore, the function\nreturns TRUE for all of the rows where 1, 2, or 500 exist (in any order or combination).",
        "If you change this query to include only the prefix 1.2 for the second argument, the default analyzer\nreturns TRUE, but the UNICODE_ANALYZER and NO_OP_ANALYZER both return FALSE. The default analyzer treats\nperiods in these values as delimiters, but the Unicode analyzer does not.",
        "The following two queries show another effect of using the UNICODE_ANALYZER instead of the default analyzer. The\nfirst query, using the UNICODE_ANALYZER, returns only one row. Note that the extra single quote in the second\nargument is there to escape the single quote for the apostrophe. See Single-quoted string constants.",
        "The second query, using the default analyzer, returns four rows because the default analyzer treats the apostrophe\ncharacter as a delimiter. Any string that contains the letter \u201cs\u201d as a token qualifies for the search.\nIn this example, the function returns TRUE for every string that contains an \u201capostrophe s\u201d ('s).",
        "The following examples show queries that return expected syntax errors.",
        "This example fails because 5 is not a supported data type for the search_string argument.",
        "This example fails because there is no column of a supported data type specified for the search_data argument.",
        "This example succeeds because there is a column of a supported data type specified for the search_data argument. The function\nignores the line_id column because it is not a supported data type",
        "This example fails because multiple string literals are listed for the first argument, without\nparentheses, resulting in mismatched arguments:",
        "This example fails because multiple column names are listed for the first argument, without\nparentheses, resulting in too many arguments:",
        "This example fails because a column name is not accepted as the search string argument.",
        "Some of the examples in this section query a table that contains text from Shakespeare\u2019s plays.\nEach line of text is stored in a single row of the table. Other columns identify the name of the play,\nthe name of the character, and so on. The lines table has the following structure:",
        "For example, a single line in this table looks like this:",
        "If you want to run the examples in this section, create this table by running the following commands:",
        "Was this page helpful?",
        "On this page"
    ]
}