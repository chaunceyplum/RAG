{
    "url": "https://docs.snowflake.com/en/sql-reference/sql/create-external-table",
    "title": "CREATE EXTERNAL TABLE | Snowflake Documentation",
    "paragraphs": [
        "Creates a new external table in the current/specified schema\nor replaces an existing external table. When queried, an external table reads\ndata from a set of one or more files in a specified external stage and outputs the data in a single VARIANT column.",
        "Additional columns can be defined, with each column definition consisting of a name, data type, and optionally whether the column requires\na value (NOT NULL) or has any referential integrity constraints (primary key, foreign key, etc.). See the usage notes for more information.",
        "ALTER EXTERNAL TABLE , DROP EXTERNAL TABLE , SHOW EXTERNAL TABLES , DESCRIBE EXTERNAL TABLE",
        "Where:",
        "For additional inline constraint details, see CREATE | ALTER TABLE \u2026 CONSTRAINT.",
        "Creates a new external table with the column definitions derived from a set of staged files containing semi-structured data. This feature supports Apache Parquet, Apache Avro, ORC, JSON, and CSV files. The support for CSV and JSON files is currently in preview.",
        "Note",
        "If the statement is replacing an existing table of the same name, then the grants are copied from the table\nbeing replaced. If there is no existing table of that name, then the grants are copied from the source table\nbeing cloned.",
        "For more details about COPY GRANTS, see COPY GRANTS in this document.",
        "String that specifies the identifier (i.e. name) for the table; must be unique for the schema in which the table is created.",
        "In addition, the identifier must start with an alphabetic character and cannot contain spaces or special characters unless the entire\nidentifier string is enclosed in double quotes (e.g. \"My object\"). Identifiers enclosed in double quotes are also case-sensitive.",
        "For more details, see Identifier requirements.",
        "Specifies the external stage and optional path where the files containing data to be read are staged:",
        "@[namespace.]ext_stage_name[/path]",
        "Files are in the specified named external stage.",
        "Neither string literals nor SQL variables are supported.",
        "Where:",
        "namespace is the database and/or schema in which the external stage resides, in the form of database_name.schema_name\nor schema_name. It is optional if a database and schema are currently in use within the user session; otherwise, it\nis required.",
        "path is an optional case-sensitive path for files in the cloud storage location (i.e. files have names that begin with a\ncommon string) that limits the set of files to load. Paths are alternatively called prefixes or folders by different cloud\nstorage services.",
        "The external table appends this path to any path specified in the stage definition. To view the stage definition,\nexecute DESC STAGE stage_name and check the url property value. For example, if the stage URL includes\npath a and the external table location includes path b, then the external table reads files staged in\nstage/a/b.",
        "Note that the [ WITH ] LOCATION value cannot reference specific filenames. To point an external table to individual\nstaged files, use the PATTERN parameter.",
        "String (constant) that specifies the file format:",
        "Specifies an existing named file format that describes the staged data files to scan. The named file format determines the format\ntype (CSV, JSON, etc.), as well as any other format options, for data files.",
        "Specifies the format type of the staged data files to scan when querying the external table.",
        "If a file format type is specified, additional format-specific options can be specified. For more details, see\nFormat Type Options (in this topic).",
        "Default: TYPE = CSV.",
        "Important",
        "An external table does not inherit FILE_FORMAT options specified in a stage definition when that stage is used for loading data into the table. To specify FILE_FORMAT options, you must explicitly do so in the external table definition. Snowflake uses defaults for any FILE_FORMAT parameters omitted from the external table definition.",
        "Note",
        "FORMAT_NAME and TYPE are mutually exclusive; to avoid unintended behavior, you should only specify one or the other\nwhen creating an external table.",
        "String that specifies the column identifier (i.e. name). All the requirements for table identifiers also apply to column identifiers.",
        "For more details, see Identifier requirements.",
        "String (constant) that specifies the data type for the column. The data type must match the result of expr for the column.",
        "For details about the data types that can be specified for table columns, see SQL data types reference.",
        "String that specifies the expression for the column. When queried, the column returns results derived from this expression.",
        "External table columns are virtual columns, which are defined using an explicit expression. Add virtual columns as expressions using the\nVALUE column and/or the METADATA$FILENAME pseudocolumn:",
        "A VARIANT type column that represents a single row in the external file.",
        "The VALUE column structures each row as an object with elements identified by column position (i.e.\n{c1: <column_1_value>, c2: <column_2_value>, c3: <column_1_value> ...}).",
        "For example, add a VARCHAR column named mycol that references the first column in the staged CSV files:",
        "Enclose element names and values in double-quotes. Traverse the path in the VALUE column using dot notation.",
        "For example, suppose the following represents a single row of semi-structured data in a staged file:",
        "Add a VARCHAR column named mycol that references the nested repeating c element in the staged file:",
        "A pseudocolumn that identifies the name of each staged data file included in the external table, including its path in the stage. For\nan example, see Partitions Added Automatically From Partition Column Expressions (in this topic).",
        "String that defines an inline or out-of-line constraint for the specified column(s) in the table.",
        "For syntax details, see CREATE | ALTER TABLE \u2026 CONSTRAINT. For more information about constraints, see\nConstraints.",
        "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is created. Refreshing\nthe external table metadata synchronizes the metadata with the current list of data files in the specified stage path. This action is\nrequired for the metadata to register any existing data files in the named external stage specified in the\n[ WITH ] LOCATION = setting.",
        "Snowflake automatically refreshes the external table metadata once after creation.",
        "Note",
        "If the specified location contains close to 1 million files or more, we recommend that you\nset REFRESH_ON_CREATE = FALSE. After creating the external table, refresh the metadata\nincrementally by executing ALTER EXTERNAL TABLE \u2026 REFRESH statements that specify subpaths in\nthe location (i.e. subsets of files to include in the refresh) until the metadata includes\nall of the files in the location.",
        "Snowflake does not automatically refresh the external table metadata. To register any existing data files in the stage, you must\nmanually refresh the external table metadata once using ALTER EXTERNAL TABLE \u2026 REFRESH.",
        "Default: TRUE",
        "Specifies whether Snowflake should enable triggering automatic refreshes of the external table metadata when new or updated data\nfiles are available in the named external stage specified in the [ WITH ] LOCATION = setting.",
        "Note",
        "Setting this parameter to TRUE is not supported by partitioned external tables when partitions are added manually by the\nobject owner (i.e. when PARTITION_TYPE = USER_SPECIFIED).",
        "Setting this parameter to TRUE is not supported for external tables that reference data files stored on an S3-compatible external stage. You must manually refresh the metadata by executing an ALTER EXTERNAL TABLE \u2026 REFRESH command.",
        "You must configure an event notification for your storage location to notify Snowflake when new or updated data is available\nto read into the external table metadata. For more information, see the instructions for your cloud storage service:",
        "Refreshing external tables automatically for Amazon S3",
        "Refreshing external tables automatically for Google Cloud Storage",
        "Refreshing external tables automatically for Azure Blob Storage",
        "When an external table is created, its metadata is refreshed automatically once unless REFRESH_ON_CREATE = FALSE.",
        "Snowflake enables triggering automatic refreshes of the external table metadata.",
        "Snowflake does not enable triggering automatic refreshes of the external table metadata. You must manually refresh the external table\nmetadata periodically using ALTER EXTERNAL TABLE \u2026 REFRESH to synchronize the metadata with the current list of files in the\nstage path.",
        "Default: TRUE",
        "A regular expression pattern string, enclosed in single quotes, specifying the filenames and/or paths on the external stage to match.",
        "Tip",
        "For the best performance, try to avoid applying patterns that filter on a large number of files.",
        "Required only when configuring AUTO_REFRESH for Amazon S3 stages using Amazon Simple Notification Service (SNS). Specifies the\nAmazon Resource Name (ARN) for the SNS topic for your S3 bucket. The CREATE EXTERNAL TABLE statement subscribes the Amazon Simple Queue\nService (SQS) queue to the specified SNS topic. Event notifications via the SNS topic trigger metadata refreshes. For more information,\nsee Refreshing external tables automatically for Amazon S3.",
        "Identifies the external table as referencing a Delta Lake on the cloud storage location. A Delta Lake on Amazon S3, Google Cloud Storage,\nor Microsoft Azure cloud storage is supported.",
        "Note",
        "This preview feature is available to all accounts.",
        "When this parameter is set, the external table scans for Delta Lake transaction log files in the [ WITH ] LOCATION location.\nDelta log files have names like _delta_log/00000000000000000000.json,\n_delta_log/00000000000000000010.checkpoint.parquet, etc.",
        "When the metadata for an external table is refreshed, Snowflake parses the Delta Lake transaction logs and determines which Parquet\nfiles are current. In the background, the refresh performs add and remove file operations to keep the external table metadata in sync.",
        "Note",
        "The external stage and optional path specified in [ WITH ] LOCATION = must contain the data files and metadata for a\nsingle Delta Lake table only. That is, the specified storage location can only contain one __delta_log\ndirectory.",
        "The ordering of event notifications triggered by DDL operations in cloud storage is not guaranteed. Therefore, the ability to\nautomatically refresh is not available for external tables that reference Delta Lake files. Both REFRESH_ON_CREATE and\nAUTO_REFRESH must be set to FALSE.",
        "Periodically execute an ALTER EXTERNAL TABLE \u2026 REFRESH statement to register any\nadded or removed files.",
        "The FILE_FORMAT value must specify Parquet as the file type.",
        "For optimal performance, we recommend defining partition columns for the external table.",
        "The following parameters are not supported when referencing a Delta Lake:",
        "AWS_SNS_TOPIC = 'string'",
        "PATTERN = 'regex_pattern'",
        "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE OR REPLACE TABLE\nvariant. The parameter copies all permissions, except OWNERSHIP, from the existing table to the new table. By default, the role\nthat executes the CREATE EXTERNAL TABLE command owns the new external table.",
        "Note",
        "The operation to copy grants occurs atomically in the CREATE EXTERNAL TABLE command (i.e. within the same transaction).",
        "String (literal) that specifies a comment for the external table.",
        "Default: No value",
        "Specifies the row access policy to set on the table.",
        "Specify the VALUE column when applying a row access policy to an external table.",
        "Specifies the tag name and the tag string value.",
        "The tag value is always a string, and the maximum number of characters for the tag value is 256.",
        "For information about specifying tags in a statement, see Tag quotas for objects and columns.",
        "Use these parameters to partition your external table.",
        "Defines one or more partition columns in the external table.",
        "The format of a partition column definition differs depending on whether partitions are computed and added automatically from an\nexpression in each partition column or the partitions are added manually.",
        "A partition column must evaluate as an expression that parses the path and/or filename information in the METADATA$FILENAME\npseudocolumn. Partition columns optimize query performance by pruning out the data files that do not need to be scanned (i.e.\npartitioning the external table). A partition consists of all data files that match the path and/or filename in the expression for\nthe partition column.",
        "part_col_name",
        "String that specifies the partition column identifier (i.e. name). All the requirements for table identifiers also apply to column identifiers.",
        "col_type",
        "String (constant) that specifies the data type for the column. The data type must match the result of part_expr for the column.",
        "part_expr",
        "String that specifies the expression for the column. The expression must include the METADATA$FILENAME pseudocolumn.",
        "External tables currently support the following subset of functions in partition expressions:",
        "List of supported functions:",
        "=, <>, >, >=, <, <=",
        "||",
        "+, -",
        "- (negate)",
        "*",
        "AND, OR",
        "ARRAY_CONSTRUCT",
        "CASE",
        "CAST , ::",
        "CONCAT , ||",
        "ENDSWITH",
        "IS [ NOT ] NULL",
        "IFF",
        "IFNULL",
        "[ NOT ] IN",
        "LOWER",
        "NOT",
        "NULLIF",
        "NVL2",
        "SPLIT_PART",
        "STARTSWITH",
        "SUBSTR , SUBSTRING",
        "UPPER",
        "ZEROIFNULL",
        "Required: Also set the PARTITION_TYPE parameter value to USER_SPECIFIED.",
        "A partition column definition is an expression that parses the column metadata in the internal (hidden)\nMETADATA$EXTERNAL_TABLE_PARTITION column. Essentially, the definition only defines the data type for the column. The format of the\npartition column definition is as follows:",
        "part_col_name col_type AS ( PARSE_JSON (METADATA$EXTERNALTABLE_PARTITION):part_col_name::data_type )",
        "For example, suppose columns col1, col2, and col3 contain varchar, number, and timestamp (time zone) data, respectively:",
        "After defining any partition columns for the table, identify these columns using the PARTITION BY clause.",
        "Note",
        "The maximum length of user-specified partition column names is 32 characters.",
        "Defines the partition type for the external table as user-defined. The owner of the external table (i.e. the role that has the\nOWNERSHIP privilege on the external table) must add partitions to the external metadata manually by executing ALTER EXTERNAL\nTABLE \u2026 ADD PARTITION statements.",
        "Do not set this parameter if partitions are added to the external table metadata automatically upon evaluation of expressions\nin the partition columns.",
        "Specifies any partition columns to evaluate for the external table.",
        "When querying an external table, include one or more partition columns in a WHERE clause, e.g.:",
        "... WHERE part_col_name = 'filter_value'",
        "Snowflake filters on the partition columns to restrict the set of data files to scan. Note that all rows in these files are scanned.\nIf a WHERE clause includes non-partition columns, those filters are evaluated after the data files have been filtered.",
        "A common practice is to partition the data files based on increments of time; or, if the data files are staged from multiple sources,\nto partition by a data source identifier and date or timestamp.",
        "Google Cloud Storage",
        "Specifies the name of the notification integration used to automatically refresh the external table metadata using Google Pub/Sub\nevent notifications. A notification integration is a Snowflake object that provides an interface between Snowflake and third-party\ncloud message queuing services.",
        "This parameter is required to enable auto-refresh operations for the external table. For instructions on configuring the\nauto-refresh capability, see Refreshing external tables automatically for Google Cloud Storage.",
        "Microsoft Azure",
        "Specifies the name of the notification integration used to automatically refresh the external table metadata using Azure Event Grid\nnotifications. A notification integration is a Snowflake object that provides an interface between Snowflake and third-party cloud\nmessage queuing services.",
        "This parameter is required to enable auto-refresh operations for the external table. For instructions on configuring the auto-refresh\ncapability, see Refreshing external tables automatically for Azure Blob Storage.",
        "Format type options are used for loading data into and unloading data out of\ntables.",
        "Depending on the file format type specified (FILE_FORMAT = ( TYPE = ... )), you can include one or more of the following\nformat-specific options (separated by blank spaces, commas, or new lines):",
        "String (constant) that specifies the current compression algorithm for the data files to be queried. Snowflake uses this option to detect\nhow already-compressed data files were compressed so that the compressed data in the files can be extracted for querying.",
        "Supported Values",
        "Notes",
        "AUTO",
        "Compression algorithm detected automatically, except for Brotli-compressed files, which cannot currently be detected automatically. If querying Brotli-compressed files, explicitly use BROTLI instead of AUTO.",
        "GZIP",
        "BZ2",
        "BROTLI",
        "Must be specified when querying Brotli-compressed files.",
        "ZSTD",
        "Zstandard v0.8 (and higher) supported.",
        "DEFLATE",
        "Deflate-compressed files (with zlib header, RFC1950).",
        "RAW_DEFLATE",
        "Raw Deflate-compressed files (without header, RFC1951).",
        "NONE",
        "Data files have not been compressed.",
        "One or more characters that separate records in an input file. Accepts common escape sequences or the following singlebyte or multibyte characters:",
        "Octal values (prefixed by \\\\) or hex values (prefixed by 0x or \\x). For example, for records delimited by the circumflex accent (^) character, specify the octal (\\\\136) or hex (0x5e) value.",
        "Hex values (prefixed by \\x). For example, for records delimited by the cent (\u00a2) character, specify the hex (\\xC2\\xA2) value.",
        "The delimiter for RECORD_DELIMITER or FIELD_DELIMITER cannot be a substring of the delimiter for the other file format option (e.g. FIELD_DELIMITER = 'aa' RECORD_DELIMITER = 'aabb').",
        "The specified delimiter must be a valid UTF-8 character and not a random sequence of bytes. Also note that the delimiter is limited to a maximum of 20 characters.",
        "Also accepts a value of NONE.",
        "Default: New line character. Note that \u201cnew line\u201d is logical such that \\r\\n is understood as a new line for files on a Windows platform.",
        "One or more singlebyte or multibyte characters that separate fields in an input file. Accepts common escape sequences or the following singlebyte or multibyte characters:",
        "Octal values (prefixed by \\\\) or hex values (prefixed by 0x or \\x). For example, for records delimited by the circumflex accent (^) character, specify the octal (\\\\136) or hex (0x5e) value.",
        "Hex values (prefixed by \\x). For example, for records delimited by the cent (\u00a2) character, specify the hex (\\xC2\\xA2) value.",
        "The delimiter for RECORD_DELIMITER or FIELD_DELIMITER cannot be a substring of the delimiter for the other file format option (e.g. FIELD_DELIMITER = 'aa' RECORD_DELIMITER = 'aabb').",
        "Note",
        "For non-ASCII characters, you must use the hex byte sequence value to get a deterministic behavior.",
        "The specified delimiter must be a valid UTF-8 character and not a random sequence of bytes. Also note that the delimiter is limited to a maximum of 20 characters.",
        "Also accepts a value of NONE.",
        "Default: comma (,)",
        "Number of lines at the start of the file to skip.",
        "Note that SKIP_HEADER does not use the RECORD_DELIMITER or FIELD_DELIMITER values to determine what a header line is; rather, it simply skips the specified number of CRLF (Carriage Return, Line Feed)-delimited lines in the file. RECORD_DELIMITER and FIELD_DELIMITER are then used to determine the rows of data to query.",
        "Default: 0",
        "Data querying only",
        "Boolean that specifies to skip any blank lines encountered in the data files; otherwise, blank lines produce an end-of-record error (default behavior).",
        "Default: FALSE",
        "A singlebyte character string used as the escape character for unenclosed field values only. An escape character invokes an alternative interpretation on subsequent characters in a character sequence. You can use the ESCAPE character to interpret instances of the FIELD_DELIMITER or RECORD_DELIMITER characters in the data as literals. The escape character can also be used to escape instances of itself in the data.",
        "Accepts common escape sequences, octal values, or hex values.",
        "Specifies the escape character for unenclosed fields only.",
        "Note",
        "The default value is \\\\. If a row in a data file ends in the backslash (\\) character, this character escapes the newline or\ncarriage return character specified for the RECORD_DELIMITER file format option. As a result, this row and the next row are\nhandled as a single row of data. To avoid this issue, set the value to NONE.",
        "This file format option supports singlebyte characters only. Note that UTF-8 character encoding represents high-order ASCII characters\nas multibyte characters. If your data file is encoded with the UTF-8 character set, you cannot specify a high-order ASCII character as\nthe option value.",
        "In addition, if you specify a high-order ASCII character, we recommend that you set the ENCODING = 'string' file format\noption as the character encoding for your data files to ensure the character is interpreted correctly.",
        "Default: backslash (\\\\)",
        "Boolean that specifies whether to remove white space from fields.",
        "For example, if your external database software encloses fields in quotes, but inserts a leading space, Snowflake reads the leading space rather than the opening quotation character as the beginning of the\nfield (that is, the quotation marks are interpreted as part of the string of field data). Set this option to TRUE to remove undesirable spaces when querying data.",
        "As another example, if leading or trailing spaces surround quotes that enclose strings, you can remove the surrounding spaces using this option and the quote character using the\nFIELD_OPTIONALLY_ENCLOSED_BY option. Note that any spaces within the quotes are preserved. For example, assuming FIELD_DELIMITER = '|' and FIELD_OPTIONALLY_ENCLOSED_BY = '\"':",
        "Note that the brackets in this example are not returned; they are used to demarcate the beginning and end of the returned strings.",
        "Default: FALSE",
        "Character used to enclose strings. Value can be NONE, single quote character ('), or double quote character (\"). To use the single quote character, use the octal or hex representation (0x27) or the double single-quoted escape ('').",
        "Default: NONE",
        "String used to convert to and from SQL NULL:",
        "When querying data, Snowflake replaces these values in the returned data with SQL NULL. To specify more than one string, enclose\nthe list of strings in parentheses and use commas to separate each value.",
        "Note that Snowflake converts all instances of the value to NULL, regardless of the data type. For example, if 2 is specified as\na value, all instances of 2 as either a string or number are converted.",
        "For example:",
        "NULL_IF = ('\\N', 'NULL', 'NUL', '')",
        "Note that this option can include empty strings.",
        "Default: \\N (that is, NULL, which assumes the ESCAPE_UNENCLOSED_FIELD value is \\\\)",
        "Specifies whether to return SQL NULL for empty fields in an input file, which are represented by two successive delimiters (e.g. ,,).",
        "If set to FALSE, Snowflake attempts to cast an empty field to the corresponding column type. An empty string is returned for columns of type STRING. For other column types, the query returns an error.",
        "Default: TRUE",
        "String (constant) that specifies the character set of the source data when querying data.",
        "Character\u00a0Set",
        "ENCODING\u00a0Value",
        "Supported Languages",
        "Notes",
        "Big5",
        "BIG5",
        "Traditional Chinese",
        "EUC-JP",
        "EUCJP",
        "Japanese",
        "EUC-KR",
        "EUCKR",
        "Korean",
        "GB18030",
        "GB18030",
        "Chinese",
        "IBM420",
        "IBM420",
        "Arabic",
        "IBM424",
        "IBM424",
        "Hebrew",
        "IBM949",
        "IBM949",
        "Korean",
        "ISO-2022-CN",
        "ISO2022CN",
        "Simplified Chinese",
        "ISO-2022-JP",
        "ISO2022JP",
        "Japanese",
        "ISO-2022-KR",
        "ISO2022KR",
        "Korean",
        "ISO-8859-1",
        "ISO88591",
        "Danish, Dutch, English, French, German, Italian, Norwegian, Portuguese, Swedish",
        "ISO-8859-2",
        "ISO88592",
        "Czech, Hungarian, Polish, Romanian",
        "ISO-8859-5",
        "ISO88595",
        "Russian",
        "ISO-8859-6",
        "ISO88596",
        "Arabic",
        "ISO-8859-7",
        "ISO88597",
        "Greek",
        "ISO-8859-8",
        "ISO88598",
        "Hebrew",
        "ISO-8859-9",
        "ISO88599",
        "Turkish",
        "ISO-8859-15",
        "ISO885915",
        "Danish, Dutch, English, French, German, Italian, Norwegian, Portuguese, Swedish",
        "Identical to ISO-8859-1 except for 8 characters, including the Euro currency symbol.",
        "KOI8-R",
        "KOI8R",
        "Russian",
        "Shift_JIS",
        "SHIFTJIS",
        "Japanese",
        "UTF-8",
        "UTF8",
        "All languages",
        "For loading data from delimited files (CSV, TSV, etc.), UTF-8 is the default. . . For loading data from all other supported file formats (JSON, Avro, etc.), as well as unloading data, UTF-8 is the only supported character set.",
        "UTF-16",
        "UTF16",
        "All languages",
        "UTF-16BE",
        "UTF16BE",
        "All languages",
        "UTF-16LE",
        "UTF16LE",
        "All languages",
        "UTF-32",
        "UTF32",
        "All languages",
        "UTF-32BE",
        "UTF32BE",
        "All languages",
        "UTF-32LE",
        "UTF32LE",
        "All languages",
        "windows-874",
        "WINDOWS874",
        "Thai",
        "windows-949",
        "WINDOWS949",
        "Korean",
        "windows-1250",
        "WINDOWS1250",
        "Czech, Hungarian, Polish, Romanian",
        "windows-1251",
        "WINDOWS1251",
        "Russian",
        "windows-1252",
        "WINDOWS1252",
        "Danish, Dutch, English, French, German, Italian, Norwegian, Portuguese, Swedish",
        "windows-1253",
        "WINDOWS1253",
        "Greek",
        "windows-1254",
        "WINDOWS1254",
        "Turkish",
        "windows-1255",
        "WINDOWS1255",
        "Hebrew",
        "windows-1256",
        "WINDOWS1256",
        "Arabic",
        "Default: UTF8",
        "Note",
        "Snowflake stores all data internally in the UTF-8 character set. The data is converted into UTF-8.",
        "String (constant) that specifies the current compression algorithm for the data files to be returned. Snowflake uses this option to\ndetect how already-compressed data files were compressed so that the compressed data in the files can be extracted for querying.",
        "Supported Values",
        "Notes",
        "AUTO",
        "Compression algorithm detected automatically, except for Brotli-compressed files, which cannot currently be detected automatically. If querying Brotli-compressed files, explicitly use BROTLI instead of AUTO.",
        "GZIP",
        "BZ2",
        "BROTLI",
        "ZSTD",
        "DEFLATE",
        "Deflate-compressed files (with zlib header, RFC1950).",
        "RAW_DEFLATE",
        "Raw Deflate-compressed files (without header, RFC1951).",
        "NONE",
        "Indicates the files have not been compressed.",
        "Default: AUTO",
        "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).",
        "Default: FALSE",
        "Boolean that instructs the JSON parser to remove outer brackets (that is, [ ]).",
        "Default: FALSE",
        "Boolean that instructs the JSON parser to remove object fields or array elements containing null values. For example, when set to TRUE:",
        "Before",
        "After",
        "[null]",
        "[]",
        "[null,null,3]",
        "[,,3]",
        "{\"a\":null,\"b\":null,\"c\":123}",
        "{\"c\":123}",
        "{\"a\":[1,null,2],\"b\":{\"x\":null,\"y\":88}}",
        "{\"a\":[1,,2],\"b\":{\"y\":88}}",
        "Default: FALSE",
        "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (\ufffd). This\noption performs a one-to-one character replacement.",
        "If set to TRUE, Snowflake replaces invalid UTF-8 characters with the Unicode replacement character.",
        "If set to FALSE, the load operation produces an error when invalid UTF-8 character encoding is detected.",
        "Default: FALSE",
        "String (constant) that specifies the current compression algorithm for the data files to be queried. Snowflake uses this option to\ndetect how already-compressed data files were compressed so that the compressed data in the files can be extracted for querying.",
        "Supported Values",
        "Notes",
        "AUTO",
        "Compression algorithm detected automatically, except for Brotli-compressed files, which cannot currently be detected automatically. If querying Brotli-compressed files, explicitly use BROTLI instead of AUTO.",
        "GZIP",
        "BZ2",
        "BROTLI",
        "ZSTD",
        "DEFLATE",
        "Deflate-compressed files (with zlib header, RFC1950).",
        "RAW_DEFLATE",
        "Raw Deflate-compressed files (without header, RFC1951).",
        "NONE",
        "Data files to query have not been compressed.",
        "Default: AUTO.",
        "Note",
        "We recommend that you use the default AUTO option because it will determine both the file and codec compression. Specifying a compression option refers to the compression of files, not the compression of blocks (codecs).",
        "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (\ufffd). This\noption performs a one-to-one character replacement.",
        "If set to TRUE, Snowflake replaces invalid UTF-8 characters with the Unicode replacement character.",
        "If set to FALSE, the load operation produces an error when invalid UTF-8 character encoding is detected.",
        "Default: FALSE",
        "Boolean that specifies whether to remove leading and trailing white space from strings.",
        "For example, if your external database software encloses fields in quotes, but inserts a leading space, Snowflake reads the leading space rather than the opening quotation character as the beginning of the field (that is, the quotation marks are interpreted as part of the string of field data). Set this option to TRUE to remove undesirable spaces.",
        "This file format option is applied to the following actions only:",
        "Querying object values in staged ORC data files.",
        "Querying ORC data in separate columns using the MATCH_BY_COLUMN_NAME copy option.",
        "Querying ORC data in separate columns by specifying a query in the COPY statement (that is, COPY transformation).",
        "Default: FALSE",
        "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (\ufffd). This\noption performs a one-to-one character replacement.",
        "If set to TRUE, Snowflake replaces invalid UTF-8 characters with the Unicode replacement character.",
        "If set to FALSE, the load operation produces an error when invalid UTF-8 character encoding is detected.",
        "Default: FALSE",
        "String used to convert to and from SQL NULL. Snowflake replaces these strings in the data source with SQL NULL. To specify more than\none string, enclose the list of strings in parentheses and use commas to separate each value.",
        "Note that Snowflake converts all instances of the value to NULL, regardless of the data type. For example, if 2 is specified as a\nvalue, all instances of 2 as either a string or number are converted.",
        "For example:",
        "NULL_IF = ('\\N', 'NULL', 'NUL', '')",
        "Note that this option can include empty strings.",
        "This file format option is applied when querying object values in staged ORC data files.",
        "Default: \\N (that is, NULL)",
        "String (constant) that specifies the current compression algorithm for columns in the Parquet files.",
        "Supported Values",
        "Notes",
        "AUTO",
        "Compression algorithm detected automatically. Supports the following compression algorithms: Brotli, gzip, Lempel-Ziv-Oberhumer (LZO), LZ4, Snappy, or Zstandard v0.8 (and higher).",
        "SNAPPY",
        "NONE",
        "Data files have not been compressed.",
        "Default: AUTO",
        "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text. When set to FALSE, Snowflake interprets these columns as binary data.",
        "Default: TRUE",
        "Note",
        "Snowflake recommends that you set BINARY_AS_TEXT to FALSE to avoid any potential conversion issues.",
        "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (\ufffd). This\noption performs a one-to-one character replacement.",
        "If set to TRUE, Snowflake replaces invalid UTF-8 characters with the Unicode replacement character.",
        "If set to FALSE, the load operation produces an error when invalid UTF-8 character encoding is detected.",
        "Default: FALSE",
        "A role used to execute this SQL command must have the following\nprivileges at a minimum:",
        "Privilege",
        "Object",
        "Notes",
        "CREATE EXTERNAL TABLE",
        "Schema",
        "CREATE STAGE",
        "Schema",
        "Required if creating a new stage.",
        "USAGE",
        "Stage",
        "Required if referencing an existing stage.",
        "USAGE",
        "File format",
        "The USAGE privilege on the parent database and schema are required to perform operations on any object in a schema.",
        "For instructions on creating a custom role with a specified set of privileges, see Creating custom roles.",
        "For general information about roles and privilege grants for performing SQL actions on\nsecurable objects, see Overview of Access Control.",
        "External tables support external (S3, Azure, or GCS) stages only; internal (Snowflake) stages are not supported.",
        "External tables don\u2019t support storage versioning (S3 versioning, Object Versioning in Google Cloud Storage, or versioning for Azure Storage).",
        "You cannot access data held in archival cloud storage classes that requires restoration before it can be retrieved. These archival storage classes include, for example, the Amazon S3 Glacier Flexible Retrieval or Glacier Deep Archive storage class, or Microsoft Azure Archive Storage.",
        "Snowflake does not enforce integrity constraints on external tables. In particular, unlike normal tables, Snowflake does not enforce\nNOT NULL constraints.",
        "External tables include the following metadata column:",
        "METADATA$FILENAME: Name of each staged data file included in the external table. Includes the path to the data file in the stage.",
        "METADATA$FILE_ROW_NUMBER: Row number for each record in the staged data file.",
        "The following are not supported for external tables:",
        "Clustering keys",
        "Cloning",
        "Data in XML format",
        "Time Travel is not supported for external tables.",
        "For details about using an external table with a policy, see:",
        "Masking policies and external tables.",
        "Row access policies and external tables.",
        "Using OR REPLACE is the equivalent of using DROP EXTERNAL TABLE on the existing external table and then creating a new\nexternal table with the same name.",
        "CREATE OR REPLACE <object> statements are atomic. That is, when an object is replaced, the old object is deleted and the new object is created in a single transaction.",
        "This means that any queries concurrent with the CREATE OR REPLACE EXTERNAL TABLE operation use either the old or new external table version.",
        "Regarding metadata:",
        "Attention",
        "Customers should ensure that no personal data (other than for a User object), sensitive data, export-controlled data, or other regulated data is entered as metadata when using the Snowflake service. For more information, see Metadata fields in Snowflake.",
        "When creating an external table with a row access policy added to the external table, use the\nPOLICY_CONTEXT function to simulate a query on the external table protected by a row access policy.",
        "SELECT * always returns the VALUE column, in which all regular or semi-structured data is cast to variant rows.",
        "Create an external table with partitions computed from expressions in the partition column definitions.",
        "In the following example, the data files are organized in cloud storage with the following structure: logs/YYYY/MM/DD/HH24.\nFor example:",
        "logs/2018/08/05/0524/",
        "logs/2018/08/27/1408/",
        "Create an external stage named s1 for the storage location where the data files are stored. For more information, see\nCREATE STAGE.",
        "The stage definition includes the path /files/logs/:",
        "Amazon S3",
        "Google Cloud Storage",
        "Microsoft Azure",
        "Query the METADATA$FILENAME pseudocolumn in the staged data. Use the results to develop your partition column(s):",
        "Create the partitioned external table.",
        "The partition column date_part casts YYYY/MM/DD in the METADATA$FILENAME pseudocolumn as a date using\nTO_DATE , DATE. The SQL command also specifies Parquet as the file format type.",
        "The external tables for Amazon S3 and Microsoft Azure cloud storage include the parameter required to refresh the metadata\nautomatically when triggered by event notifications from the respective cloud messaging service:",
        "Amazon S3",
        "Google Cloud Storage",
        "Microsoft Azure",
        "Refresh the external table metadata:",
        "When querying the external table, filter the data by the partition column using a WHERE clause. Snowflake only scans the files in the\nspecified partitions that match the filter conditions:",
        "Create an external table with user-defined partitions (i.e. the partitions are added manually by the external table owner).",
        "Create an external stage named s2 for the storage location where the data files are stored:",
        "The stage definition includes the path /files/logs/:",
        "Amazon S3",
        "Google Cloud Storage",
        "Microsoft Azure",
        "Create the partitioned external table. The external table includes three partition columns with different data types.",
        "Note that the column names in the partition expressions are case-sensitive. The following rules apply:",
        "A partition column name must be in uppercase, unless the column name is enclosed in double quotes. Alternatively,\nuse GET_IGNORE_CASE instead of the case-sensitive : character in the SQL\nexpression.",
        "If a column name is enclosed in double quotes (e.g. \u201cColumn1\u201d), the partition column name must also be enclosed in\ndouble quotes and match the column name exactly.",
        "The syntax for each of the three cloud storage services (Amazon S3, Google Cloud Storage, and Microsoft Azure) is identical\nbecause the external table metadata is not refreshed:",
        "Add partitions for the partition columns:",
        "Snowflake adds the partitions to the metadata for the external table. The operation also adds any new data files in the specified\nlocation to the metadata:",
        "When querying the external table, filter the data by the partition columns using a WHERE clause. This example returns the records in the\norder they are stored in the staged data files:",
        "Create a partitioned external table named ext_twitter_feed that references the Delta Lake files in Parquet format in the mystage\nexternal stage and daily path.",
        "The partition column date_part casts YYYY/MM/DD in the METADATA$FILENAME pseudocolumn as a date using\nTO_DATE , DATE:",
        "Create a materialized view based on a subquery of the columns in the external table created in the\nPartitions Added Automatically From Partition Column Expressions example:",
        "For general syntax, usage notes, and further examples for this SQL command, see CREATE MATERIALIZED VIEW.",
        "Create an external table where the column definitions are derived from a set of staged files that contain Avro, Parquet, or ORC data.",
        "Note that the mystage stage and my_parquet_format file format referenced in the statement must already exist. A set of files must\nalready be staged in the cloud storage location referenced in the stage definition.",
        "This example builds on an example in the INFER_SCHEMA topic:",
        "Using * for ARRAY_AGG(OBJECT_CONSTRUCT()) may result in an error if the returned result is larger than 16\u00a0MB. Avoid using * for larger result sets, and only use the required columns, COLUMN NAME, TYPE, and NULLABLE, for the query, as the following example demonstrates. Optional column ORDER_ID can be included when using WITHIN GROUP (ORDER BY order_id).",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}