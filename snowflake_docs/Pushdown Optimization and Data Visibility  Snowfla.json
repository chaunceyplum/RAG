{
    "url": "https://docs.snowflake.com/en/developer-guide/pushdown-optimization",
    "title": "Pushdown Optimization and Data Visibility | Snowflake Documentation",
    "paragraphs": [
        "Through the pushdown optimization, Snowflake helps make query processing faster and more efficient by filtering rows. However, due to the\nway filters can be reordered, pushdown can expose data that you might not want to be visible.",
        "This topic describes pushdown and how it can expose sensitive data. To prevent sensitive data from becoming visible, you can make a\nUDF secure as described in Protecting Sensitive Information with Secure UDFs and Stored Procedures.",
        "Pushdown improves performance by filtering out unneeded rows as early as possible during query processing. Pushdown can also reduce memory\nconsumption. However, pushdown can allow confidential data to be exposed indirectly.",
        "Consider the following query:",
        "One approach to processing the query is:",
        "Read all rows from the table into memory (i.e. execute the FROM clause).",
        "Scan the rows in memory, filtering out any rows that do not match New York (i.e. execute the WHERE clause).",
        "Select col1 from the rows still remaining in memory (i.e. execute the SELECT list).",
        "You can think of this as a \u201cload first, filter later\u201d strategy, which is straight-forward, but inefficient.",
        "It\u2019s usually more efficient to filter as early as possible. Early filtering is called \u201cpushing the filter down deeper into the query plan\u201d,\nor simply \u201cpushdown\u201d.",
        "In example query above, it would be more efficient to tell the table-scanning code not to load records that don\u2019t match the WHERE clause. This\ndoesn\u2019t save filtering time (every row\u2019s location must still be read once), but it can save considerable memory and reduce subsequent processing\ntime because there are fewer rows to process.",
        "In some cases, you can process the data even more efficiently. For example, suppose that the data is partitioned by state (i.e. all the data\nfor New York is in one micro-partition, all the data for Florida is in another micro-partition, and so on). In this scenario:",
        "Snowflake does not need to store all the rows in memory.",
        "Snowflake does not need to read all the rows.",
        "We loosely define this as another form of \u201cpushdown\u201d.",
        "The principle of \u201cpushing down the filters\u201d applies to a wide range of queries. Often, the filter that is the most selective (screens out\nthe most data) is pushed deepest (executed earliest) to reduce the work that the remaining query must do.",
        "Pushdown can be combined with other techniques, such as clustering (sorting/ordering the data), to reduce the amount of irrelevant data that\nneeds to be read, loaded, and processed.",
        "The following example shows one way that pushdown could indirectly result in the exposure of underlying details about a query. This example\nfocuses on views, but the same principles apply to UDFs.",
        "Suppose there is a table that stores information about patients:",
        "There are two views, one of which shows mental health information and one of which shows physical health information:",
        "Most users don\u2019t have direct access to the table. Instead, users are assigned one of two roles:",
        "MentalHealth, which has privileges to read from mental_health_view, or",
        "PhysicalHealth, which has privileges to read from physical_health_view.",
        "Now suppose that a doctor with privileges only on physical health data wants to know whether there are currently any mental health patients\nin the table. The doctor can construct a query similar to the following:",
        "This query is equivalent to:",
        "There are (at least) two methods that Snowflake can use to process this query.",
        "Method 1:",
        "Read all the rows in the patients table.",
        "Apply the view\u2019s security filter (i.e. filter out the rows for which the category is not PhysicalHealth).",
        "Apply the WHERE clause in the query (i.e. filter based on WHERE 1/IFF(category = 'MentalHealth', 0, 1) = 1).",
        "Method 2 changes the order of the filters, so that the query executes as follows:",
        "Read all the rows in the patients table.",
        "Apply the WHERE clause in the query (i.e. filter based on WHERE 1/IFF(category = 'MentalHealth', 0, 1) = 1).",
        "Apply the view\u2019s security filter (i.e. filter out the rows for which the category is not PhysicalHealth).",
        "Logically, these two sequences seem equivalent; they return the same set of rows. However, depending on how selective these two filters are,\none order of processing might be faster, and Snowflake\u2019s query planner might choose the plan that executes faster.",
        "Suppose that the optimizer chooses the second plan, in which the clause WHERE 1/IFF(category = 'MentalHealth', 0, 1) = 1 is executed\nbefore the security filter. If the patients table has any rows in which category = 'MentalHealth', then the IFF function returns\n0 for that row, and the clause effectively becomes WHERE 1/0 = 1, so the statement causes a divide-by-zero error. The user with\nphysical_health_view privileges does not see any rows for people with mental health issues, but can deduce that at least one person in the\nmental health category exists.",
        "Note that this technique does not always result in exposing underlying details; it relies heavily on the choices that the query planner makes,\nas well as on how the views (or UDFs) are written. But this example shows that a user can deduce information about rows that the user cannot\nview directly.",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}