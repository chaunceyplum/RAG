{
    "url": "https://docs.snowflake.com/en/user-guide/dynamic-tables-performance-queries",
    "title": "Dynamic table query performance | Snowflake Documentation",
    "paragraphs": [
        "This section discusses how to design your pipeline to get good performance at query time. Your data\ntakes various forms as it moves through different systems:",
        "Source data: Initially, data is generated by real-world entities and collected in frontline\nsystems. This data is then ingested into Snowflake via ETL processes.",
        "Raw data: After ingestion, the data is stored in Snowflake tables, where it\u2019s transformed\ninto a form more suitable for analysis.",
        "Modeled data: These transformations result in a set of models, which present familiar concepts\nto consumers for analysis.",
        "Your pipeline comprises these steps. Dynamic tables work in the transformation steps,\nbut you should consider their performance in the context of your overall pipeline.",
        "The performance of analysis queries is determined by the design and implementation of the transformations\nfrom raw to modeled data. While defining these transformations as a set of views over raw data is\ntechnically correct, it might not meet performance and cost needs.",
        "To address this, some or all data models might need to be materialized by precomputing their\nresults, storing them for quick access, and keeping them up to date. Dynamic tables make this\nmaterialization easy, but you still have to decide which of your models to materialize.",
        "The division between the materialized and unmaterialized part of the transformation is referred to as\nthe materialization boundary. When deciding on the materialization boundary, the following\nfactors are typically relevant:",
        "Lag or Freshness: The freshness of the data you\nprovide, which is how out of date your results are. The materialization boundary typically doesn\u2019t\nhave a strong effect on this factor.",
        "Response time: Materializing more of\nyour pipeline reduces response time. Freshness is always at least as long as the response time of\nyour queries, but can be much longer.",
        "Cost: The cost of your workload is associated with the\nfollowing:",
        "Cost of materialization: This cost scales with the amount of data in the sources and the\ncomplexity of the transformations.",
        "Cost of computing the unmaterialized transformations during analysis: This cost scales with\nthe number of analytical queries and their complexity.",
        "Cost of storage: This cost includes both the raw and materialized data.",
        "Materializing more modeled data speeds up response times and lowers analysis cost but can raise\nmaterialization costs. Finding the best materialization boundary requires balancing the above factors.\nTypically, you can get good results by materializing the least amount of data that still meets your\nresponse time requirements.",
        "After you\u2019ve set your materialization boundary, you can create dynamic tables and views accordingly. You\ncan optimize the performance of the unmaterialized transformations just like any other Snowflake query.\nAfter you query them, regular and dynamic tables perform similarly, letting you use standard techniques like\nnormalization, pre-aggregation, and clustering to boost performance.",
        "For more ideas, see the query performance checklist.",
        "Was this page helpful?",
        "On this page"
    ]
}