{
    "url": "https://docs.snowflake.com/en/user-guide/data-load-considerations-prepare",
    "title": "Preparing your data files | Snowflake Documentation",
    "paragraphs": [
        "This topic provides best practices, general guidelines, and important considerations for preparing your data files for loading.",
        "For best load performance and to avoid size limitations, consider the following data file sizing guidelines. Note that these recommendations apply to bulk data loads as well as continuous loading using Snowpipe.",
        "The number of load operations that run in parallel can\u2019t exceed the number of data files to be loaded. To optimize the number of parallel operations for a load, we recommend aiming to produce data files roughly 100-250 MB (or larger) in size compressed.",
        "Note",
        "Loading very large files (e.g. 100 GB or larger) is not recommended.",
        "If you must load a large file, carefully consider the ON_ERROR copy option value. Aborting or\nskipping a file due to a small number of errors could result in delays and wasted credits. In addition, if a data loading operation\ncontinues beyond the maximum allowed duration of 24 hours, it could be aborted without any portion of the file being committed.",
        "Aggregate smaller files to minimize the processing overhead for each file. Split larger files into a greater number of smaller files to distribute the load among the compute resources in an active warehouse. The number of data files that are processed in parallel is determined by the amount of compute resources in a warehouse. We recommend splitting large files by line to avoid records that span chunks.",
        "If your source database does not allow you to export data files in smaller chunks, you can use a third-party utility to split large CSV files.",
        "The split utility enables you to split a CSV file into multiple smaller files.",
        "Syntax:",
        "For more information, type man split in a terminal window.",
        "Example:",
        "This example splits a file named pagecounts-20151201.csv by line length. Suppose the large single file is 8 GB and contains 10 million lines. Split by 100,000, each of the 100 smaller files is 80 MB (10 million / 100,000 = 100). The split files are named pagessuffix.",
        "Windows does not include a native file split utility; however, Windows supports many third-party tools and scripts that can split large data files.",
        "Note",
        "To use this feature, you must enable the 2024_08 behavior change bundle in your account.",
        "To enable this bundle in your account,\nexecute the following statement:",
        "An error occurs if you attempt to load an object larger than 16 MB from a file on a stage into one of the\nfollowing types of columns:",
        "VARCHAR (including the types that are synonymous with VARCHAR)",
        "BINARY (including the types that are synonymous with BINARY)",
        "VARIANT",
        "OBJECT",
        "ARRAY",
        "GEOGRAPHY",
        "GEOMETRY",
        "The following error occurs because the maximum size of an object stored in a column is 16 MB:",
        "In the past, this error also occurred if you attempted to query a file on a stage, and\nthe file contained objects larger than 16 MB.",
        "Although you still can\u2019t store objects larger than 16 MB in a column, you can now query objects up to 128 MB\nin files on a stage. You can then reduce the size of the objects before storing the objects in columns. An error no longer\noccurs when you query a file containing objects larger than 16 MB but smaller than 128 MB.",
        "For example, you can split large objects across multiple columns or rows, transform nested JSON into a tabular format, or\nsimplify complex geometries.",
        "In general, JSON data sets are a simple concatenation of multiple documents. The JSON output from some software is composed of a single huge array containing multiple records. There is no need to separate the documents with line breaks or commas, but both are supported.",
        "If the data exceeds 16 MB, enable the STRIP_OUTER_ARRAY file format option for the COPY INTO <table> command to remove the outer array structure and load the records into separate table rows:",
        "Suppose that you\u2019re loading a Parquet file from a stage, and the Parquet file contains a JSON object that\u2019s larger than 16 MB\nin size:",
        "The following example creates a table to store the data from the file and loads the data into the table. Because the size of the\narray of events can exceed 16 MB, the example expands the array of events into separate rows (one for each array element).",
        "The following is an example of the contents of the resulting table.",
        "To insert the results of the FLATTEN function into an existing table, use an\nINSERT statement. For example:",
        "Suppose that you\u2019re loading an XML file from a stage, and it contains an XML object that\u2019s larger than 16 MB:",
        "The following example creates a table to store the data from the file and loads the data into the table. Because the\nsize of the XML can exceed 16 MB, the example expands each node into separate rows.",
        "The following is an example of the contents of the resulting table.",
        "Suppose that you\u2019re loading a Parquet file from a stage, and the Parquet file contains a geospatial object that\u2019s larger than\n16 MB. You can load the file from the stage and simplify the geospatial object (by using\nST_SIMPLIFY) before you store the object:",
        "If you need to use COPY INTO <table> to load data from a file on a stage, you can\u2019t use FLATTEN\nto split up large objects. Instead, use SELECT. For example:",
        "Snowpipe is designed to load new data typically within a minute after a file notification is sent; however, loading can take significantly longer for really large files or in cases where an unusual amount of compute resources is necessary to decompress, decrypt, and transform the new data.",
        "In addition to resource consumption, an overhead to manage files in the internal load queue is included in the utilization costs charged for Snowpipe. This overhead increases in relation to the number of files queued for loading. This overhead charge appears as Snowpipe charges in your billing statement\nbecause Snowpipe is used for event notifications for the automatic external table refreshes.",
        "For the most efficient and cost-effective load experience with Snowpipe, we recommend following the file sizing recommendations in File Sizing Best Practices and Limitations (in this topic). Loading data files roughly 100-250 MB or larger reduces the overhead charge relative to the amount of total data loaded to the point where the overhead cost is immaterial.",
        "If it takes longer than one minute to accumulate MBs of data in your source application, consider creating a new (potentially smaller) data file once per minute. This approach typically leads to a good balance between cost (i.e. resources spent on Snowpipe queue management and the actual load) and performance (i.e. load latency).",
        "Creating smaller data files and staging them in cloud storage more often than once per minute has the following disadvantages:",
        "A reduction in latency between staging and loading the data can\u2019t be guaranteed.",
        "An overhead to manage files in the internal load queue is included in the utilization costs charged for Snowpipe. This overhead increases in relation to the number of files queued for loading.",
        "Various tools can aggregate and batch data files. One convenient option is Amazon Data Firehose. Firehose allows defining both the\ndesired file size, called the buffer size, and the wait interval after which a new file is sent (to cloud storage in this case), called\nthe buffer interval. For more information, see the\nAmazon Data Firehose documentation. If your source application\ntypically accumulates enough data within a minute to populate files larger than the recommended maximum for optimal parallel processing,\nyou could decrease the buffer size to trigger delivery of smaller files. Keeping the buffer interval setting at 60 seconds (the minimum\nvalue) helps avoid creating too many files or increasing latency.",
        "Consider the following guidelines when preparing your delimited text (CSV) files for loading:",
        "UTF-8 is the default character set, however, additional encodings are supported. Use the ENCODING file format option to specify the character set for the data files. For more information, see CREATE FILE FORMAT.",
        "Fields that contain delimiter characters should be enclosed in quotes (single or double). If the data contains single or double quotes, then those quotes must be escaped.",
        "Carriage returns are commonly introduced on Windows systems in conjunction with a line feed character to mark the end of a line (\\r \\n). Fields that contain carriage returns should also be enclosed in quotes (single or double).",
        "The number of columns in each row should be consistent.",
        "When semi-structured data is inserted into a VARIANT column, Snowflake uses certain rules to extract as much of the data as possible\nto a columnar form. The rest of the data is stored as a single column in a parsed semi-structured structure.",
        "By default, Snowflake extracts a maximum of 200 elements per partition, per table. To increase this limit, contact Snowflake Support.",
        "Elements with the following characteristics are not extracted into a column:",
        "Elements that contain even a single \u201cnull\u201d value are not extracted into a column.\nThis applies to elements with \u201cnull\u201d values and not to elements with missing values, which are represented in columnar form.",
        "This rule ensures that no information is lost (that is, that the difference between VARIANT \u201cnull\u201d values and SQL NULL values is not lost).",
        "Elements that contain multiple data types. For example:",
        "The foo element in one row contains a number:",
        "The same element in another row contains a string:",
        "When you query a semi-structured element, Snowflake\u2019s execution engine behaves differently according to whether an element was extracted.",
        "If the element was extracted into a column, the engine scans only the extracted column.",
        "If the element was not extracted into a column, the engine must scan the entire JSON structure,\nand then for each row traverse the structure to output values. This impacts performance.",
        "To avoid the performance impact for elements that were not extracted, do the following:",
        "Extract semi-structured data elements containing \u201cnull\u201d values into relational columns before you load them.",
        "Alternatively, if the \u201cnull\u201d values in your files indicate missing values and have no other special meaning,\nwe recommend setting the file format option STRIP_NULL_VALUES to TRUE\nwhen you load the semi-structured data files. This option removes OBJECT elements or ARRAY elements containing \u201cnull\u201d values.",
        "Ensure each unique element stores values of a single data type that is native to the format (for example, string or number for JSON).",
        "Avoid embedded characters, such as commas (e.g. 123,456).",
        "If a number includes a fractional component, it should be separated from the whole number portion by a decimal point (e.g. 123456.789).",
        "Oracle only. The Oracle NUMBER or NUMERIC types allow for arbitrary scale, meaning they accept values with decimal components even if the data type was not defined with a precision or scale. Whereas in Snowflake, columns designed for values with decimal components must be defined with a scale to preserve the decimal portion.",
        "For information on the supported formats for date, time, and timestamp data, see Date and time input and output formats.",
        "Oracle only. The Oracle DATE data type can contain date or timestamp information. If your Oracle database includes DATE columns that also store time-related information, map these columns to a TIMESTAMP data type in Snowflake rather than DATE.",
        "Note",
        "Snowflake checks temporal data values at load time. Invalid date, time, and timestamp values (e.g. 0000-00-00) produce an error.",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}