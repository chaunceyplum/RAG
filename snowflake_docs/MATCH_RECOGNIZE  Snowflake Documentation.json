{
    "url": "https://docs.snowflake.com/en/sql-reference/constructs/match_recognize",
    "title": "MATCH_RECOGNIZE | Snowflake Documentation",
    "paragraphs": [
        "Query syntax",
        "Recognizes matches of a pattern in a set of rows. MATCH_RECOGNIZE accepts a set of rows (from a table,\nview, subquery, or other source) as input, and returns all matches for a given row pattern within this\nset. The pattern is defined similarly to a regular expression.",
        "The clause can return either:",
        "All the rows belonging to each match.",
        "One summary row per match.",
        "MATCH_RECOGNIZE is typically used to detect events in time series. For example, MATCH_RECOGNIZE can search a\nstock price history table for shapes like V (down followed by up) or W (down, up, down, up).",
        "MATCH_RECOGNIZE is an optional subclause of the FROM clause.",
        "Note",
        "You cannot use the MATCH_RECOGNIZE clause in a recursive common table expression (CTE).",
        "Identifying Sequences of Rows That Match a Pattern",
        "Symbols (also known as \u201cpattern variables\u201d) are the building blocks of the pattern.",
        "A symbol is defined by an expression. If the expression evaluates to true for a row, the symbol is assigned to\nthat row. A row can be assigned multiple symbols.",
        "Symbols that are not defined in the DEFINE clause, but are used in the pattern, are always assigned to all\nrows. Implicitly, they are equivalent to the following example:",
        "Patterns are defined based on symbols and operators.",
        "The pattern defines a valid sequence of rows that represents a match. The pattern is defined like a regular\nexpression (regex) and is built from symbols, operators, and quantifiers.",
        "For example, suppose that symbol S1 is defined as stock_price < 55, and symbol S2 is defined\nas stock price > 55. The following pattern specifies a sequence of rows in which the stock price increased\nfrom less than 55 to greater than 55:",
        "The following is a more complex example for a pattern definition:",
        "The following section describes the individual components of this pattern in detail.",
        "Note",
        "MATCH_RECOGNIZE uses backtracking to match patterns. As is the case with other\nregular expression engines that use backtracking,\nsome combinations of patterns and data to match can take a long time to execute, which can result in high computation costs.",
        "To improve performance, define a pattern that is as specific as possible:",
        "Make sure that each row matches only one symbol or a small number of symbols",
        "Avoid using symbols that match every row (e.g. symbols not in the DEFINE clause or symbols that are defined as true)",
        "Define an upper limit for quantifiers (e.g. {,10} instead of *).",
        "For example, the following pattern can result in increased costs if no rows match:",
        "If there is an upper limit to the number of rows that you want to match, you can specify that limit in the quantifiers to\nimprove performance. In addition, rather than specifying that you want to find any_symbol that follows symbol1, you can\nlook for a row that is not symbol1  (not_symbol1, in this example);",
        "In general, you should monitor the query execution time to verify that the query is not taking longer than expected.",
        "",
        "A symbol matches to a row that symbol was assigned to. The following symbols are available:",
        "symbol.  For example, S1, \u2026 , S4\nThose are symbols that were defined in the DEFINE subclause and are evaluated per row.\n(These can also include symbols that were not defined and are automatically assigned to all rows.)",
        "^ (Start of partition.)\nThis is a virtual symbol that denotes the start of a partition and has no row associated with it. You can use it\nto require a match to start only at the beginning of a partition.",
        "For an example, see Matching Patterns Relative to the Beginning or End of a Partition.",
        "$ (End of partition.)\nThis is a virtual symbol that denotes the end of a partition and has no row associated with it. You can use it\nto require a match to end only at the end of a partition.",
        "For an example, see Matching Patterns Relative to the Beginning or End of a Partition.",
        "",
        "A quantifier can be placed following a symbol or operation. A quantifier denotes the minimum and maximum number of\noccurrences of the associated symbol or operation. The following quantifiers are available:",
        "Quantifier",
        "Meaning",
        "+",
        "1 or more. For example, ( {- S3 -} S4 )+.",
        "*",
        "0 or more. For example, S2*?.",
        "?",
        "0 or 1.",
        "{n}",
        "Exactly n.",
        "{n,}",
        "n or more.",
        "{,m}",
        "0 to m.",
        "{n, m}",
        "n to m. For example, PERMUTE(S1, S2){1,2}.",
        "By default, quantifiers are in \u201cgreedy mode\u201d, which means they try to match the maximum quantity if possible. To put a\nquantifier into \u201creluctant mode\u201d, in which the quantifier tries to match the minimum quantity if possible,\nplace a ? after the quantifier (e.g. S2*?).",
        "",
        "Operators specify in which order symbols or other operations should occur in the sequence of rows to form a valid\nmatch. The following operators are available:",
        "Operator",
        "Meaning",
        "... ... (space)",
        "Concatenation. Specifies that a symbol or operation should follow another one. For example, S1 S2 means that the condition defined for S2 should occur after the condition defined for S1.",
        "{- ... -}",
        "Exclusion. Excludes the contained symbols or operations from the output. For example, {- S3 -} excludes operator S3 from the output. Excluded rows will not appear in the output, but will be included in the evaluation of MEASURES expressions.",
        "( ... )",
        "Grouping. Used to override the precedence of an operator or to apply the same quantifier for symbols or operations in the group. In this example, the quantifier + applies to the sequence {- S3 -} S4, not merely S4.",
        "PERMUTE(..., ...)",
        "Permutation. Matches any permutation of the specified patterns. For example, PERMUTE(S1, S2) matches either S1 S2 or S2 S1. PERMUTE() takes an unlimited number of arguments.",
        "... | ...",
        "Alternative. Specifies that either the first symbol or operation or the other one should occur. For example, ( S3 S4 ) | PERMUTE(S1, S2). The alternative operator has precedence over the concatenation operator.",
        "Where:",
        "Define the order of the rows as you would for\nwindow functions. This is the order in which the individual rows of\neach partition are passed to the MATCH_RECOGNIZE operator.",
        "For more information, see Partitioning and Sorting the Rows.",
        "Partition the input set of rows as you would for window functions.\nMATCH_RECOGNIZE performs matching individually for each resulting partition.",
        "Partitioning not only groups rows that are related to each other, but also leverages Snowflake\u2019s\ndistributed data processing capability because separate partitions can be processed in parallel.",
        "For more information about partitioning, see Partitioning and Sorting the Rows.",
        "\u201cMeasures\u201d are optional additional columns that are added to the output of the MATCH_RECOGNIZE operator.\nThe expressions in the MEASURES subclause have the same capabilities as the expressions in the DEFINE\nsubclause. For further information, see Symbols.",
        "Within the MEASURES subclause, the following functions specific to MATCH_RECOGNIZE are available:",
        "MATCH_NUMBER()\nReturns the sequential number of the match. The MATCH_NUMBER starts from 1, and is incremented for each match.",
        "MATCH_SEQUENCE_NUMBER()\nReturns the row number within a match. The MATCH_SEQUENCE_NUMBER is sequential and starts from 1.",
        "CLASSIFIER()\nReturns a TEXT value that contains the symbol that the respective row matched. For example, if a row matched\nthe symbol GT75, then the CLASSIFIER function returns the string \u201cGT75\u201d.",
        "Note",
        "When specifying measures, remember the restrictions mentioned in the\nLimitations on window functions used in DEFINE and MEASURES section.",
        "Specifies which rows are returned for a successful match. This subclause is optional.",
        "ALL ROWS PER MATCH: Return all rows in the match.",
        "ONE ROW PER MATCH: Return one summary row for each match, regardless of how many rows are in the match.\nThis is the default.",
        "Be aware of the following special cases:",
        "Empty Matches: An empty match happens if a pattern is able to match against zero rows. For instance, if the pattern\nis defined as A* and the first row at the beginning of a matching attempt is assigned to symbol B, then an\nempty match including only that row is generated, because the * quantifier in the A* pattern allows 0\noccurrences of A to be treated as a match. The MEASURES expressions are evaluated differently for this row:",
        "The CLASSIFIER function returns NULL.",
        "Window functions return NULL.",
        "The COUNT function returns 0.",
        "Unmatched Rows: If a row was not matched against the pattern, it is called an unmatched row. MATCH_RECOGNIZE can\nbe configured to return unmatched rows, too. For unmatched rows, expressions in the MEASURES subclause return\nNULL.",
        "Exclusions",
        "The exclusion syntax ({- ... -}) in the pattern definition allows users to exclude certain rows from the output.\nIf all matched symbols in the pattern were excluded, no row is generated for that match if ALL ROWS PER MATCH was\nspecified. Note that the MATCH_NUMBER is incremented anyway. Excluded rows are not part of the result, but are\nincluded for the evaluation of MEASURES expressions.",
        "When using the exclusion syntax, the ROWS PER MATCH subclause can be specified as follows:",
        "ONE ROW PER MATCH (default)",
        "Returns exactly one row for each successful match. The default window function semantic for window functions in\nthe MEASURES subclause is FINAL.",
        "The output columns of the MATCH_RECOGNIZE operator are all expressions given in the PARTITION BY subclause\nand all MEASURES expressions. All resulting rows of a match are grouped by the expressions given in the\nPARTITION BY subclause and the MATCH_NUMBER using the ANY_VALUE aggregation function for all measures.\nTherefore, if measures evaluate to a different value for different rows of the same match, then the output is\nnon-deterministic.",
        "Omitting the PARTITION BY and MEASURES subclause results in an error indicating that the result does not\ninclude any columns.",
        "For empty matches, a row is generated. Unmatched rows are not part of the output.",
        "ALL ROWS PER MATCH",
        "Returns a row for each row that is part of the match, except for rows that were matched to a portion of the\npattern that was marked for exclusion.",
        "Excluded rows are still taken into account in computations in the MEASURES subclause.",
        "Matches might overlap based on the AFTER MATCH SKIP TO subclause, so the same row might appear multiple times\nin the output.",
        "The default window function semantic for window functions in the MEASURES subclause is RUNNING.",
        "The output columns of the MATCH_RECOGNIZE operator are the columns of the set of rows being input and the\ncolumns defined in the MEASURES subclause.",
        "The following options are available for ALL ROWS PER MATCH:",
        "SHOW EMPTY MATCHES (default)\nAdd empty matches to the output. Unmatched rows are not output.",
        "OMIT EMPTY MATCHES\nNeither empty matches nor unmatched rows are output. However, the MATCH_NUMBER is still incremented by an\nempty match.",
        "WITH UNMATCHED ROWS\nAdds empty matches and unmatched rows to the output. If this clause is used, then the pattern must not contain\nexclusions.",
        "For an example that uses exclusion to reduce irrelevant output, see\nSearch for Patterns in Non-Adjacent Rows.",
        "This subclause specifies where to continue the matching after a positive match was found.",
        "PAST LAST ROW (default)",
        "Continue matching after the last row of the current match.",
        "This prevents matches that contain overlapping rows. For example, if you have a stock pattern that contains\n3 V shapes in a row, then PAST LAST ROW finds one W pattern, not two.",
        "TO NEXT ROW",
        "Continue matching after the first row of the current match.",
        "This allows matches that contain overlapping rows. For example, if you have a stock pattern that contains 3 V\nshapes in a row, then TO NEXT ROW finds two W patterns (the first pattern is based on the first two V\nshapes, and the second W shape is based on the second and third V shapes; thus both patterns contain the\nsame V).",
        "TO [ { FIRST | LAST } ] <symbol>",
        "Continue matching at the first or last (default) row that was matched to the given symbol.",
        "At least one row needs to be mapped to the given symbol or an error is raised.",
        "If this does not skip past the first row of the current match, then an error is raised.",
        "The DEFINE and MEASURES clauses allow expressions. Those expressions can be complex and can include\nwindow functions and special navigational functions (which are a type of\nwindow function).",
        "In most respects, expressions in DEFINE and MEASURES follow the rules for expressions elsewhere in Snowflake\nSQL syntax. However, there are some differences, which are described below:",
        "Navigational functions allow references to other rows besides the current row. For example, to create an expression\nthat defines a drop in price, you need to compare the price in one row to the price in another row.\nThe navigational functions are:",
        "PREV( expr [ , offset [, default ] ] )\nNavigate to the previous row within the current match in the MEASURES subclause.",
        "This function is currently not available in the DEFINE subclause. Instead, you can use LAG which\nnavigates to the previous row within the current window frame.",
        "NEXT( expr [ , offset [ , default ] ] )\nNavigate to the next row within the current window frame. This function is\nequivalent to LEAD.",
        "FIRST( expr )\nNavigate to the first row of the current match in the MEASURES subclause.",
        "This function is currently not available in the DEFINE subclause. Instead, you can use FIRST_VALUE\nwhich navigates to the first row of the current window frame.",
        "LAST( expr )\nNavigate to the last row of the current window frame. This function is similar to\nLAST_VALUE, but for LAST the window frame is limited to the current row of the current matching\nattempt when LAST is used within the DEFINE subclause.",
        "For an example that uses the navigational functions, see\nReturning Information About the Match.",
        "In general, when a window function is used inside a MATCH_RECOGNIZE clause, the window function does not require\nits own OVER (PARTITION BY ... ORDER BY ...) clause. The window is implicitly determined by\nthe PARTITION BY and ORDER BY of the MATCH_RECOGNIZE clause. (However, see\nLimitations on window functions used in DEFINE and MEASURES for some exceptions.)",
        "In general, the window frame is also derived implicitly from the current context in\nwhich the window function is being used. The lower bound of the frame is defined as described below:",
        "In the DEFINE subclause:",
        "The frame starts at the beginning of the current matching attempt except when using LAG, LEAD,\nFIRST_VALUE, and LAST_VALUE.",
        "In the MEASURES subclause:",
        "The frame starts at the beginning of the match that was found.",
        "The edges of the window frame can be specified by using either RUNNING or FINAL semantics.",
        "RUNNING:",
        "In general, the frame ends at the current row. However, the following exceptions exist:",
        "In the DEFINE subclause, for LAG, LEAD, FIRST_VALUE, LAST_VALUE, and NEXT,\nthe frame ends at the last row of the window.",
        "In the MEASURES subclause, for PREV, NEXT, LAG, and LEAD, the frame ends at the\nlast row of the window.",
        "In the DEFINE subclause, RUNNING is the default (and the only allowed) semantic.",
        "In the MEASURES subclause, when the ALL ROWS PER MATCH subclause is used, RUNNING is the\ndefault.",
        "FINAL:",
        "The frame ends at the last row of the match.",
        "FINAL is allowed only in the MEASURES subclause. It is the default there when\nONE ROW PER MATCH applies.",
        "Expressions within the DEFINE and MEASURES subclauses allow symbols as predicates for column references.",
        "The <symbol> indicates a row that was matched, and the <column> identifies a specific column within that row.",
        "A predicated column reference means that the surrounding window function only looks at rows that were finally\nmapped to the specified symbol.",
        "Predicated column references can be used outside and inside of a window function. If used outside of a window\nfunction, <symbol>.<column> is the same as LAST(<symbol>.<column>). Inside of a window function,\nall column references either need to be predicated with the same symbol or are all non-predicated.",
        "The following explains how navigational-related functions behave with predicated column references:",
        "PREV/LAG( ... <symbol>.<column> ... , <offset>)\nSearches the window frame backwards starting from and including the current row (or last row in case of a\nFINAL semantic) for the first row that was finally mapped to the specified <symbol>, and then\ngoes <offset> (default is 1) rows backwards, ignoring the symbol those rows were mapped to. If the searched part of the\nframe does not contain a row mapped to <symbol> or the search would go beyond the edge of the frame, then NULL is returned.",
        "NEXT/LEAD( ... <symbol>.<column> ... , <offset>)\nSearches the window frame backwards starting from and including the current row (or last row in case of\na FINAL semantic) for the first row that was finally mapped to the specified <symbol>, and then\ngoes <offset> (default is 1) rows forward, ignoring the symbol those rows were mapped to. If the searched part of the\nframe does not contain a row mapped to <symbol> or the search would go beyond the edge of the frame, then NULL is returned.",
        "FIRST/FIRST_VALUE( ... <symbol>.<column> ... )\nSearches the window frame forwards starting from and including the first row up to and including the current row\n(or last row in case of a FINAL semantic) for the first row that was finally mapped to the specified <symbol>.\nIf the searched part of the frame does not contain a row mapped to <symbol>, NULL is returned.",
        "LAST/LAST_VALUE( ... <symbol>.<column> ... )\nSearches the window frame backwards starting from and including the current row (or last row in case of a\nFINAL semantic) for the first row that was finally mapped to the specified <symbol>. If the searched part of\nthe frame does not contain a row mapped to <symbol>, NULL is returned.",
        "Note",
        "Restrictions on window functions are documented in the Limitations on window functions used in DEFINE and MEASURES section.",
        "Expressions in the DEFINE and MEASURES subclauses can include window functions. However, there are some\nlimitations on using window functions in these subclauses. These limitations are shown in the table below:",
        "Function",
        "DEFINE (Running) [column/symbol.column]",
        "MEASURES (Running) [column/symbol.column]",
        "MEASURES (Final) [column/symbol.column]",
        "Column",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "PREV(\u2026)",
        "\u274c / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "NEXT(\u2026)",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "FIRST(\u2026)",
        "\u274c / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "LAST(\u2026)",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "LAG()",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "LEAD()",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "FIRST_VALUE()",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "LAST_VALUE()",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "Aggregations [1]",
        "\u2714 / \u274c",
        "\u2714 / \u2714",
        "\u2714 / \u2714",
        "Other window functions [1]",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "\u2714 / \u274c",
        "These functions require an explicit frame definition (OVER (ROWS BETWEEN ...)) when used in the DEFINE clause.",
        "The MATCH_RECOGNIZE-specific functions MATCH_NUMBER(), MATCH_SEQUENCE_NUMBER(), and CLASSIFIER() are\ncurrently not available in the DEFINE subclause.",
        "When you use the ONE ROW PER MATCH clause, only columns and expressions from the PARTITION BY and MEASURES\nsubclauses are allowed in the projection clause of the SELECT. If you try to use MATCH_RECOGNIZE without either a\nPARTITION BY or MEASURES clause, you get  an error similar to SELECT with no columns.",
        "For more information about ONE ROW PER MATCH vs. ALL ROWS PER MATCH,\nsee Generating One Row for Each Match vs Generating All Rows for Each Match.",
        "The topic Identifying Sequences of Rows That Match a Pattern contains many examples, including some that are simpler than\nmost of the examples here. If you are not already familiar with MATCH_RECOGNIZE, then you might want to read those\nexamples first.",
        "Some of the examples below use the following table and data:",
        "The following graph shows the shapes of the curves:",
        "The following query searches for all V shapes in the previously presented stock_price_history. The output is\nexplained in more detail after the query and output.",
        "The output shows one row per match (regardless of how many rows were part of the match).",
        "The output includes the following columns:",
        "COMPANY: The stock symbol for the company.",
        "The MATCH_NUMBER is a sequential number identifying which match this was within this data set (e.g. the first match\nhas MATCH_NUMBER 1, the second match has MATCH_NUMBER 2, etc.). If the data was partitioned, then the MATCH_NUMBER\nis the sequential number within the partition (in this example, for each company/stock).",
        "START_DATE: The date at which this occurrence of the pattern starts.",
        "END_DATE: The date at which this occurrence of the pattern ends.",
        "ROWS_IN_SEQUENCE: This is the number of rows in the match. For example, the first match is based on the prices\nmeasured on 4 days (October 1 through October 4), so ROWS_IN_SEQUENCE is 4.",
        "NUM_DECREASES: This is the number of days (within the match) that the price went down. For example, in the first match, the\nprice went down for 1 day and then went up for 2 days, so NUM_DECREASES is 1.",
        "NUM_INCREASES: This is the number of days (within the match) that the price went up. For example, in the first match, the\nprice went down for 1 day and then went up for 2 days, so NUM_INCREASES is 2.",
        "This example returns all rows within each match (not just one summary row per match). This pattern searches for\nrising prices of the \u2018ABCD\u2019 company:",
        "This searches for price ranges above the average of the whole chart of a company. This example omits empty matches.\nNote, however, that empty matches nonetheless increment the MATCH_NUMBER:",
        "This example demonstrates the WITH UNMATCHED ROWS option. Like the\nOmit empty matches example above, this example searches for price ranges\nabove the average price of each company\u2019s chart. Note that the quantifier in this query is +, while the\nquantifier in the previous query was *:",
        "This example shows the use of <symbol>.<column> notation with symbol predicates:",
        "Was this page helpful?",
        "On this page",
        "Related content"
    ]
}