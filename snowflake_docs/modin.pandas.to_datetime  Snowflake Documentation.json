{
    "url": "https://docs.snowflake.com/en/developer-guide/snowpark/reference/python/1.26.0/modin/pandas_api/modin.pandas.to_datetime",
    "title": "modin.pandas.to_datetime | Snowflake Documentation",
    "paragraphs": [
        "Convert argument to datetime.",
        "This function converts a scalar, array-like, Series or\nDataFrame/dict-like to a pandas datetime object.",
        "arg (int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like) \u2013 The object to convert to a datetime. If a DataFrame is provided, the\nmethod expects minimally the following columns: \"year\",\n\"month\", \"day\".",
        "errors ({'ignore', 'raise', 'coerce'}, default 'raise') \u2013",
        "If 'raise', then invalid parsing will raise an exception.",
        "If 'coerce', then invalid parsing will be set as NaT.",
        "If 'ignore', then invalid parsing will return the input.",
        "",
        "dayfirst (bool, default False) \u2013",
        "Specify a date parse order if arg is str or is list-like.\nIf True, parses dates with the day first, e.g. \"10/11/12\"\nis parsed as 2012-11-10.",
        "Warning",
        "dayfirst=True is not strict, but will prefer to parse\nwith day first. If a delimited date string cannot be parsed in\naccordance with the given dayfirst option, e.g.\nto_datetime(['31-12-2021']), then a warning will be shown.",
        "",
        "yearfirst (bool, default False) \u2013",
        "Specify a date parse order if arg is str or is list-like.",
        "If True parses dates with the year first, e.g.\n\"10/11/12\" is parsed as 2010-11-12.",
        "If both dayfirst and yearfirst are True, yearfirst is\npreceded (same as dateutil).",
        "Warning",
        "yearfirst=True is not strict, but will prefer to parse\nwith year first.",
        "",
        "utc (bool, default None) \u2013",
        "Control timezone-related parsing, localization and conversion.",
        "If True, the function always returns a timezone-aware\nUTC-localized Timestamp, Series or\nDatetimeIndex. To do this, timezone-naive inputs are\nlocalized as UTC, while timezone-aware inputs are converted to UTC.",
        "If False (default), inputs will not be coerced to UTC.\nTimezone-naive inputs will remain naive, while timezone-aware ones\nwill keep their time offsets. Limitations exist for mixed\noffsets (typically, daylight savings), see Examples section for details.",
        "See also: pandas general documentation about timezone conversion and\nlocalization.",
        "",
        "format (str, default None) \u2013 The strftime to parse time, e.g. \"%d/%m/%Y\". Note that\n\"%f\" will parse all the way up to nanoseconds. See\nstrftime documentation for more information on choices.",
        "exact (bool, default True) \u2013",
        "Control how format is used:",
        "If True, require an exact format match.",
        "If False, allow the format to match anywhere in the target\nstring.",
        "",
        "unit (str, default 'ns') \u2013 The unit of the arg (D,s,ms,us,ns) denote the unit, which is an\ninteger or float number. This will be based off the origin.\nExample, with unit='ms' and origin='unix', this would calculate\nthe number of milliseconds to the unix epoch start.",
        "infer_datetime_format (bool, default False) \u2013 If True and no format is given, attempt to infer the format\nof the datetime strings based on the first non-NaN element,\nand if it can be inferred, switch to a faster method of parsing them.\nIn some cases this can increase the parsing speed by ~5-10x.",
        "origin (scalar, default 'unix') \u2013",
        "Define the reference date. The numeric values would be parsed as number\nof units (defined by unit) since this reference date.",
        "If 'unix' (or POSIX) time; origin is set to 1970-01-01.",
        "If 'julian', unit must be 'D', and origin is set to\nbeginning of Julian Calendar. Julian day number 0 is assigned\nto the day starting at noon on January 1, 4713 BC.",
        "If Timestamp convertible, origin is set to Timestamp identified by\norigin.",
        "",
        "cache (bool, default True) \u2013 cache parameter is ignored with Snowflake backend, i.e., no caching will be\napplied",
        "",
        "If parsing succeeded.\nReturn type depends on input (types in parenthesis correspond to\nfallback in case of unsuccessful timezone or out-of-range timestamp\nparsing):",
        "scalar: Timestamp (or datetime.datetime)",
        "array-like: DatetimeIndex (or\n:class: Series of object dtype containing\ndatetime.datetime)",
        "Series: Series of datetime64 dtype (or\n:class: Series of object dtype containing\ndatetime.datetime)",
        "DataFrame: Series of datetime64 dtype (or\nSeries of object dtype containing\ndatetime.datetime)",
        "",
        "datetime",
        "ParserError \u2013 When parsing a date from string fails.",
        "ValueError \u2013 When another datetime conversion error happens. For example when one\n    of \u2018year\u2019, \u2018month\u2019, day\u2019 columns is missing in a DataFrame, or\n    when a Timezone-aware datetime.datetime is found in an array-like\n    of mixed time offsets, and utc=False.",
        "See also",
        "Cast argument to a specified dtype.",
        "Convert argument to timedelta.",
        "Convert dtypes.",
        "Notes",
        "Many input types are supported, and lead to different output types:",
        "scalars can be int, float, str, datetime object (from stdlib datetime\nmodule or numpy). They are converted to Timestamp when\npossible, otherwise they are converted to datetime.datetime.\nNone/NaN/null scalars are converted to NaT.",
        "array-like can contain int, float, str, datetime objects. They are\nconverted to DatetimeIndex when possible, otherwise they are\nconverted to Index with object dtype, containing\ndatetime.datetime. None/NaN/null entries are converted to\nNaT in both cases.",
        "Series are converted to Series with datetime64\ndtype when possible, otherwise they are converted to Series with\nobject dtype, containing datetime.datetime. None/NaN/null\nentries are converted to NaT in both cases.",
        "DataFrame/dict-like are converted to Series with\ndatetime64 dtype. For each row a datetime is created from assembling\nthe various dataframe columns. Column keys can be common abbreviations\nlike [\u2018year\u2019, \u2018month\u2019, \u2018day\u2019, \u2018minute\u2019, \u2018second\u2019, \u2018ms\u2019, \u2018us\u2019, \u2018ns\u2019]) or\nplurals of the same.",
        "The following causes are responsible for datetime.datetime objects\nbeing returned (possibly inside an Index or a Series with\nobject dtype) instead of a proper pandas designated type\n(Timestamp or Series with datetime64 dtype):",
        "when any input element is before Timestamp.min or after\nTimestamp.max, see timestamp limitations.",
        "when utc=False (default) and the input is an array-like or\nSeries containing mixed naive/aware datetime, or aware with mixed\ntime offsets. Note that this happens in the (quite frequent) situation when\nthe timezone has a daylight savings policy. In that case you may wish to\nuse utc=True.",
        "Examples",
        "Handling various input formats",
        "Assembling a datetime from multiple columns of a DataFrame. The keys\ncan be common abbreviations like [\u2018year\u2019, \u2018month\u2019, \u2018day\u2019, \u2018minute\u2019, \u2018second\u2019,\n\u2018ms\u2019, \u2018us\u2019, \u2018ns\u2019]) or plurals of the same",
        "Passing infer_datetime_format=True can often-times speedup a parsing\nif it\u2019s not an ISO8601 format exactly, but in a regular format.",
        "Using a unix epoch time",
        "Warning",
        "For float arg, precision rounding might happen. To prevent\nunexpected behavior use a fixed-width exact type.",
        "Using a non-unix epoch origin",
        "Non-convertible date/times",
        "If a date does not meet the timestamp limitations, passing errors='ignore'\nwill return the original input instead of raising any exception.",
        "Passing errors='coerce' will force an out-of-bounds date to NaT,\nin addition to forcing non-dates (or non-parseable dates) to NaT.",
        "Timezones and time offsets",
        "The default behaviour (utc=False) is as follows:",
        "Timezone-naive inputs are kept as timezone-naive DatetimeIndex:",
        "Use right format to convert to timezone-aware type (Note that when call Snowpark\npandas API to_pandas() the timezone-aware output will always be converted to session timezone):",
        "Timezone-aware inputs with mixed time offsets (for example\nissued from a timezone with daylight savings, such as Europe/Paris):",
        "Setting utc=True makes sure always convert to timezone-aware outputs:",
        "Timezone-naive inputs are localized based on the session timezone",
        "Timezone-aware inputs are converted to session timezone",
        "Was this page helpful?"
    ]
}