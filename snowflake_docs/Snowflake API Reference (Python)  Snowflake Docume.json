{
    "url": "https://docs.snowflake.com/en/developer-guide/snowflake-python-api/reference/latest/index",
    "title": "Snowflake API Reference (Python) | Snowflake Documentation",
    "paragraphs": [
        "Snowflake API (Python) allows you to manage Snowflake resources by using Python APIs. For more\ninformation, see the Snowflake API Developer Guide for Python.",
        "The Snowflake platform has a rich SQL command API which lets you\ninteract with Snowflake entities, creating, deleting, modifying them, and\nmore.  The library described here, called the \u201cSnowflake Python API\u201d (or\n\u201cSnowAPI\u201d for short) provides the same functionality using the Python\nlanguage.",
        "Here is a quick overview of the concepts, classes, and functionality for using\nPython to interact with the Snowflake platform, in most cases eliminating the\nneed to write SQL, or use the Python SQL connector.",
        "Before you begin, you must define your connection to Snowflake.",
        "Note",
        "Snowflake is actively evolving the connection definition mechanism, to\nmake it easier and safer to define your connections.  These instructions\nwill change before the public release of SnowAPI.",
        "You can define your connection information in a dictionary in your code [1]\nlike so:",
        "You then use this connection information to create a session:",
        "The SnowAPI is organized as a tree of resources, modeling the resources\navailable in the Snowflake REST API [2].  You\u2019ll need to first instantiate\nroot of this resource tree in order to interact with other Snowflake\nobjects:",
        "When instantiating the root object, you need to either pass in a session, as\nshown here, or a SnowflakeConnection object.",
        "There are two important concepts that help you understand how the SnowAPI\nlibrary functions.  Python objects that you create and interact with are\neither local references (a.k.a. handles), or snapshots of state stored on\nSnowflake.  This separation is made because communicating with Snowflake\nincurs costs - network activity and performance costs, but also usage credit\ncosts.  For this reason SnowAPI exposes explicit operations when it talks to\nSnowflake.",
        "In general, if you act on or retrieve information from Snowflake, you do so\nthrough a local, in-memory reference object.  These references do not\nsynchronize with Snowflake until you call a given method.  Calling a method is\na good indication of communication with Snowflake, which incurs some or all of\nthe costs outlined above.  Other operations on in-memory references incur no\nsuch costs.",
        "We\u2019ll call out these differences as we explore more examples.",
        "In this example, we\u2019ll step through creating a task in Snowflake, providing\nits definition, naming it, pushing it to Snowflake, as well as suspending,\nresuming, and deleting the task.",
        "In order to create a task, we first create a task object describing the task.\nWe\u2019ll give it a name, a definition, and a schedule to run.  Because this is a\nlocal reference, this task definition lives only on the client side; it has\nnot been pushed to Snowflake.",
        "This task_definition object isn\u2019t a local reference per se, it\u2019s simply a\nPython object that holds a description of the task which can be pushed to\nSnowflake in order to create the task.",
        "This task definition must be pushed into Snowflake before it can execute.  As\nyou can see from the SQL CREATE TASK documentation,\ntask creation requires a schema.  In Python terms, this means that creating a\nnew task must happen relative to an existing schema object.  Schemas in turn\nare relative to a database.",
        "Before we can create the task in Snowflake, we need to build a local path to\nthe database and schema where the task will be created.  This is done by using\nmapping-like syntax in various collections, rooted at the root object.\nHere\u2019s how we build a path to a schema named \u201cpublic\u201d in the database named\n\u201cmy_db\u201d.  Note most importantly that this is purely local; no communication\nwith Snowflake occurs.",
        "As you can see, these are just the local reference objects for the database\nand schema, and accessing their attributes just parrots the name\nattributes back to you as you gave them.  Now we\u2019re ready to push this task\ndefinition into Snowflake:",
        "This method call communicates with Snowflake.",
        "This object actually is the local reference object, and it holds a handle to\nthe task object created in Snowflake.  But its properties haven\u2019t been\nretrieved from Snowflake yet.  In order to do that, we have to make a call on\nthe reference object, returning a \u201csnapshot\u201d object which does contain the\nproperties of the newly created task.  You\u2019ll see this pattern often, where\nfetching the snapshot communicates with Snowflake, retrieving the properties\nof the referenced object.",
        "Notice that the name on the reference object is lower case while the name on\nthe task snapshot object is upper case.  That\u2019s because Snowflake stores the\ntask name in upper case and the .fetch() call sync\u2019d this value to the\nlocal snapshot object.",
        "Note",
        "Be aware that this snapshot is only guaranteed to be current as of the\nmoment the .fetch() executes.  After that, changes to underlying\nSnowflake objects are not reflected in the local snapshot objects.  You\nmust call .fetch() again to re-sync the data locally.",
        "The snapshot task object has additional attributes on it, such as the task\nschedule:",
        "and the task\u2019s schema name (notice the upper case again here):",
        "The task reference object has some additional attributes and methods too.  You\ncan get the task\u2019s fully qualified name:",
        "You can also execute, resume, and suspend the task by using methods on the\ntask reference object:",
        "You can also delete the task by using the task reference object.",
        "Of course, once you\u2019ve done this, you can\u2019t resume, suspend, or execute the\ntask, because it no longer exists.  You also can\u2019t call .fetch() to get\nthe latest snapshop object.  All of these operations return 404 Not Found\nexceptions (note that the full traceback is omitted here):",
        "The example given here does require you to include connection\ninformation in your Python source code.  Take care not to leak\nsensitive information such as your password!",
        "https://docs.snowflake.com/en/developer-guide/snowflake-rest-api/snowflake-rest-api",
        "Was this page helpful?",
        "On this page"
    ]
}