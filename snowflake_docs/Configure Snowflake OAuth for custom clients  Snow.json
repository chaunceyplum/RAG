{
    "url": "https://docs.snowflake.com/en/user-guide/oauth-custom",
    "title": "Configure Snowflake OAuth for custom clients | Snowflake Documentation",
    "paragraphs": [
        "This topic describes how to configure OAuth support for custom clients.",
        "The following high-level steps are required to configure OAuth for custom clients:",
        "Register your client with Snowflake. To register your client, create an integration. An integration is a Snowflake object that provides\nan interface between Snowflake and third-party services, such as a client that supports OAuth.",
        "The registration process defines a client ID and client secrets.",
        "Configure calls to the Snowflake OAuth endpoints to request authorization codes from the Snowflake authorization server and to request\nand refresh access tokens.",
        "The optional \u201cscope\u201d parameters in the initial authorization request limit the role permitted by the access token and can additionally\nbe used to configure the refresh token behavior.",
        "Note",
        "In-session role switching to secondary roles is not supported with Snowflake OAuth.",
        "If this behavior is necessary with your OAuth workflow, use External OAuth instead.",
        "For more information, see Using secondary roles with External OAuth.",
        "Create a Snowflake OAuth integration using the\nCREATE SECURITY INTEGRATION command. Be sure to\nspecify OAUTH_CLIENT = CUSTOM when creating the integration.",
        "Note",
        "Only account administrators (users with the ACCOUNTADMIN role) or a role with the global CREATE INTEGRATION privilege can execute this\nSQL command.",
        "The optional BLOCKED_ROLES_LIST parameter allows you to list Snowflake roles that a user cannot explicitly consent to using with\nthe integration.",
        "By default, the ACCOUNTADMIN, SECURITYADMIN, and ORGADMIN roles are included in this list and cannot be removed. If you have a business\nneed to allow users to use Snowflake OAuth with these roles, and your security team allows it, please contact\nSnowflake Support to request that these roles be allowed for your account.",
        "Snowflake supports using Client Redirect with Snowflake OAuth Custom Clients, including using Client Redirect and OAuth with supported\nSnowflake Clients.",
        "For more information, see Redirecting client connections.",
        "Snowflake supports network policies for OAuth. For more information, see Network policies.",
        "The following example creates an OAuth integration that uses key pair authentication. The integration allows refresh tokens, which expire\nafter 1 day (86400 seconds). The integration blocks users from starting a session with SYSADMIN as the active role:",
        "OAuth endpoints are the URLs that clients call to request authorization codes and to request and refresh access tokens. These endpoints\nrefer to specific OAuth 2.0 policies that execute when the endpoint is called.",
        "Snowflake provides the following OAuth endpoints:",
        "<snowflake_account_url>/oauth/authorize",
        "<snowflake_account_url>/oauth/token-request",
        "Where <snowflake_account_url> is a valid Snowflake account URL. For example, you might use the endpoints\nhttps://myorg-account_xyz.snowflakecomputing.com/oauth/authorize and\nhttps://myorg-account_xyz.snowflakecomputing.com/oauth/token-request. For a list of supported formats for the Snowflake account URL,\nsee Connecting with a URL.",
        "To see a list of valid OAuth endpoints for a security integration, execute DESCRIBE INTEGRATION,\nand then view the values in the  OAUTH_ALLOWED_AUTHORIZATION_ENDPOINTS and OAUTH_ALLOWED_TOKEN_ENDPOINTS properties.",
        "The authorization endpoint is used to obtain an authorization grant after a user successfully authorizes a client with Snowflake.",
        "Important",
        "The authorization endpoint must be opened in a browser that the user can interact with. Do not use cURL with this endpoint.",
        "The authorization endpoint is as follows:",
        "Where:",
        "Specifies a valid Snowflake account URL. For example,\nhttps://myorg-account_xyz.snowflakecomputing.com/oauth/authorize.",
        "GET",
        "Note",
        "The following parameters should be URL encoded.",
        "Parameter",
        "Data Type",
        "Required?",
        "Description",
        "client_id",
        "String",
        "Yes",
        "Client ID (provided by Snowflake when the client is registered)",
        "response_type",
        "String",
        "Yes",
        "Response type created. Currently supports code value, because Snowflake only issues authorization codes.",
        "redirect_uri",
        "String",
        "Yes",
        "URI where the user is redirected to after successfully authorizing. In general, this should match the value of the\nOAUTH_REDIRECT_URI parameter of the security integration.",
        "However, if the redirect_uri includes query parameters, do not include those query parameters when defining the\nOAUTH_REDIRECT_URI parameter of the security integration. For example, if the value of the redirect_uri query parameter in\nthe request to the authorization endpoint is https://www.example.com/connect?authType=snowflake, make sure the\nOAUTH_REDIRECT_URI parameter in the security integration is set to https://www.example.com/connect.",
        "state",
        "String",
        "No",
        "String of no more than 2048 ASCII characters that is returned with the response from the Snowflake authorization server. Typically\nused to prevent cross-site request forgery attacks.",
        "scope",
        "String",
        "No",
        "Space-delimited string that is used to limit the scope of the access request. For more information, refer to Scope\n(in this topic).",
        "code_challenge",
        "String",
        "No",
        "Challenge for Proof Key for Code Exchange (PKCE). String generated via a secret and a code challenge method. For more information,\nrefer to Proof key for code exchange (in this topic).",
        "code_challenge_method",
        "String",
        "No",
        "String indicating the method used to derive the code challenge for PKCE. For more information, refer to\nProof key for code exchange (in this topic).",
        "When a user authorizes the client, a redirect is made to the redirect_uri that contains the following in a GET request:",
        "Query Parameter",
        "Description",
        "code",
        "Short-lived authorization code, which can be exchanged at the token endpoint for an access token.",
        "state",
        "state value provided in the original request, unmodified.",
        "scope",
        "Scope of the access request; currently the same as the scope value in the initial authorization request, but might differ in the future. For more information, see Scope (in this topic).",
        "The scope query parameter in the initial authorization request optionally limits the operations and role permitted by the access token.",
        "Scope is validated immediately when making an authorization request with respect to semantics, but not necessarily validity. That is, any\ninvalid scopes (e.g. \u201cbogus_scope\u201d) are rejected before the user authenticates, but a scope the user does not have access to (a\nparticular role, etc.) does not result in an error until after the user authenticates.",
        "The following are the possible values of the scope query parameter:",
        "Scope Value",
        "Required?",
        "Description",
        "refresh_token",
        "No",
        "If included in the authorization URL, Snowflake presents the user with the option to consent to offline access. In this context,\noffline access refers to allowing the client to refresh access tokens when the user is not present. With user consent, the\nauthorization server returns a refresh token in addition to an access token when redeeming the authorization code.",
        "session:role:role_name",
        "No",
        "Used to limit the access token to a single role that the user can consent to for the session. Only one session role scope can\nbe specified. If this scope is omitted, then the default role for the user is used instead. When a user authorizes consent, Snowflake\nalways displays the role for the session regardless if this scope is included in the authorization URL.",
        "Note that role_name is case-sensitive and must be input in all uppercase unless the role name was enclosed in quotes when\nit was created using CREATE ROLE. To verify the case, execute SHOW ROLES in\nSnowflake and see the role name in the output.",
        "If the role name contains characters that are reserved in a query parameter URL, you must use\na session:role-encoded:role_name syntax, where role_name is a URL-encoded string. For example, if the role name is\nAUTH SNOWFLAKE (with a space), then the value of the scope query parameter must be\nsession:role-encoded:AUTH%20SNOWFLAKE.",
        "The following example limits authorization to the custom R1 role:",
        "The following example indicates that access/refresh tokens should use the default role for the user and requests a refresh token so that\noffline access can occur:",
        "The following example limits authorization to the custom R1 role and requests a refresh token so that offline access can occur:",
        "This endpoint returns access tokens or refresh tokens depending on the request parameters. The token endpoint is as follows:",
        "Where:",
        "Specifies a valid Snowflake account URL. For example,\nhttps://myorg-account_xyz.snowflakecomputing.com/oauth/token-request.",
        "POST",
        "Ensure that the content-type header in the POST request is set as follows:",
        "The client ID and client secret must be included in the authorization header. Currently, Snowflake only supports the\nBasic Authentication Scheme, which means that the value expected is in the following form:",
        "Basic Base64(client_id:client_secret)",
        "Where:",
        "Header Value",
        "Data Type",
        "Required",
        "Description",
        "client_id",
        "String",
        "Yes",
        "Client ID of the integration.",
        "client_secret",
        "String",
        "Yes",
        "Client secret for the integration.",
        "Both the client ID and client secret can be retrieved using the SYSTEM$SHOW_OAUTH_CLIENT_SECRETS function.",
        "Note the : character between client_id and client_secret.",
        "Parameter",
        "Data Type",
        "Required",
        "Description",
        "grant_type",
        "String",
        "Yes",
        "Type of grant requested: . authorization_code indicates that an authorization code should be exchanged for an access token. . refresh_token indicates a request to refresh an access token.",
        "code",
        "String",
        "Yes",
        "Authorization code returned from the token endpoint. Used and required when grant_type is set to authorization_code.",
        "refresh_token",
        "String",
        "Yes",
        "Refresh token returned from an earlier request to the token endpoint when redeeming the authorization code. Used and required when grant_type is set to refresh_token.",
        "redirect_uri",
        "String",
        "Yes",
        "Redirect URI as used in the authorization URL when requesting an authorization code. Used and required when grant_type is set to authorization_code.",
        "code_verifier",
        "String",
        "No",
        "Required only if the authorization request was sent to the Authorization Endpoint with a code_challenge parameter value. Code verifier for PKCE. For more information, see Proof key for code exchange (in this topic).",
        "A JSON object is returned with the following fields:",
        "Field",
        "Data Type",
        "Description",
        "access_token",
        "String",
        "Access token used to establish a Snowflake session",
        "refresh_token",
        "String",
        "Refresh token. Not issued if the client is configured to not issue refresh tokens or if the user did not consent to the refresh_token scope.",
        "expires_in",
        "Integer",
        "Number of seconds remaining until the token expires",
        "token_type",
        "String",
        "Access token type. Currently, always Bearer.",
        "username",
        "String",
        "Username that the access token belongs to. Currently only returned when exchanging an authorization code for an access token.",
        "The following example shows a successful response when exchanging an authorization code for an access and refresh token:",
        "The following example shows an unsuccessful response:",
        "The message string value is a description of the error and error is the error type. For more information on the types of\nerrors returned, see OAuth Error Codes.",
        "This endpoint returns an OAuth access token in exchange for a JSON Web Token (JWT). For an example, see Tutorial 1 (step 5). In the  tutorial you send a request to this endpoint to exchange a JWT token for an OAuth token and use the OAuth token to access a public endpoint exposed by a Snowpark Container Services service.",
        "The token endpoint is as follows:",
        "Where:",
        "Specifies a valid Snowflake account URL. For example,\nhttps://myorg-account_xyz.snowflakecomputing.com/oauth/token.",
        "POST",
        "Ensure that the content-type header in the POST request is set as follows:",
        "Parameter",
        "Data Type",
        "Required",
        "Description",
        "grant_type",
        "String",
        "Yes",
        "Pass this as string urn:ietf:params:oauth:grant-type:jwt-bearer .",
        "scope",
        "String",
        "Yes",
        "Pass this as string session:role:role_name <ingress-endpoint-url>. Note that the role_name is case sensitive. Use the SHOW ENDPOINTS IN SERVICE command to find the ingress endpoint URL. .",
        "assertion",
        "String",
        "Yes",
        "Pass the JWT token.",
        "For example,",
        "When specifying scope, the session:role:role_name is optional. If not provided, the default role of the user is used.",
        "An OAuth access token is returned",
        "Snowflake supports Proof Key for Code Exchange (PKCE) for obtaining access tokens using the authorization_code grant type as\ndescribed in RFC 7636. PKCE can be used to lessen the possibility of an authorization code\ninterception attack, and is suitable for clients that might not be able to fully keep the client secret secure.",
        "By default, PKCE is optional and is enforced only if the code_challenge and code_challenge_method parameters are both\nincluded in the authorization endpoint URL. However, Snowflake highly recommends that your client require PKCE for all authorizations to\nmake the OAuth flow more secure.",
        "The following describes how PKCE for Snowflake works:",
        "The client creates a secret called the code verifier and performs a transformation on it to generate the code challenge. The client\nholds onto the secret.",
        "Important",
        "Generate the code verifier from the allowed ASCII characters according to\nSection 4.1 of RFC 7636.",
        "The client directing the user to the Authorization URL appends the following two query parameters:",
        "Specifies the code challenge generated in Step 1.",
        "Specifies the transformations used on the code verifier in Step 1 to generate the code challenge. Currently, Snowflake only supports\nSHA256, so this value must be set to S256. The transformation algorithm for SHA256 is\nBASE64URL-ENCODE(SHA256(ASCII(code_verifier))).",
        "After the user consents to the requested scopes or Snowflake determines that consent is present for that user, the authorization code\nis issued.",
        "The client receives the authorization code from the Snowflake authorization server, which it then submits along with the\ncode_verifier in the request to the token endpoint.",
        "Snowflake transforms the code_verifier value and verifies that the transformed value matches the code_challenge value\nused when generating authorizations. If these values match, then the authorization server issues the access and refresh tokens.",
        "Snowflake supports using key pair authentication rather than the typical username/password authentication when calling the OAuth token\nendpoint. This authentication method requires a 2048-bit (minimum) RSA key pair. Generate the PEM (Privacy Enhanced Mail) public-private\nkey pair using OpenSSL. The public key is assigned to the Snowflake user who uses the Snowflake client.",
        "To configure the public/private key pair:",
        "From the command line in a terminal window, generate an encrypted private key:",
        "OpenSSL prompts for a passphrase used to encrypt the private key file. Snowflake recommends using a strong passphrase to protect the private\nkey. Record this passphrase. You must input it when connecting to Snowflake. Note that the passphrase is only used for protecting\nthe private key and is never sent to Snowflake.",
        "Sample PEM private key",
        "From the command line, generate the public key by referencing the private key:",
        "Sample PEM public key",
        "Copy the public and private key files to a local directory for storage. Record the path to the files.",
        "Note that the private key is stored using the PKCS#8 (Public Key Cryptography Standards) format and is encrypted using the passphrase\nyou specified in the previous step; however, the file should still be protected from unauthorized access using the file permission\nmechanism provided by your operating system. It is your responsibility to secure the file when it is not being used.",
        "Assign the public key to the integration object using ALTER SECURITY INTEGRATION. For example:",
        "Note",
        "Only account administrators can execute the ALTER SECURITY INTEGRATION command.",
        "Exclude the public key header and footer in the command.",
        "Verify the public key fingerprint using DESCRIBE INTEGRATION:",
        "Note",
        "The OAUTH_CLIENT_RSA_PUBLIC_KEY_2_FP property is described in Key Rotation (in this topic).",
        "Modify and execute the sample code below. The code uses the private key to encode a JWT and then passes that token to the Snowflake\nauthorization server:",
        "Update the security parameters:",
        "<private_key>: Open the rsa_key.p8 file in a text editor, and copy the lines between the\nBEGIN header and the END footer.",
        "Update the session parameters:",
        "<account_identifier>: Specifies the full name of your account (provided by Snowflake).",
        "Update the JSON Web Token (JWT) fields:",
        "A JSON object with the following standard fields (\u201cclaims\u201d):",
        "Attribute",
        "Data Type",
        "Required",
        "Description",
        "iss",
        "String",
        "Yes",
        "Specifies the principal that issued the JWT in the format client_id.public_key_fp where client_id is the client ID of the OAuth client integration and public_key_fp is the fingerprint of the public key that is used during verification.",
        "sub",
        "String",
        "Yes",
        "Subject of the JWT in the format account_identifier.client_id where",
        "account_identifier is the full name of your Snowflake account and client_id is the client ID of the OAuth client integration. Depending on the cloud platform (AWS or Azure) and region where your account is hosted, the full account name might require additional segments. For more information, see the account variable description under Token endpoint.",
        "iat",
        "Timestamp",
        "No",
        "Time when the token was issued.",
        "exp",
        "Timestamp",
        "Yes",
        "Time when the token should expire. This period should be relatively short (e.g. a few minutes).",
        "Sample code",
        "Note that the private_key value includes the -----BEGIN header and the -----END footer.",
        "After the token is created, submit it in requests to the token endpoint. Requests require the Bearer authorization format as the\nauthorization header instead of the basic authorization format normally used for the client ID and client secret, as follows:",
        "Snowflake supports multiple active keys to allow for uninterrupted rotation. Rotate and replace your public and private keys based on the\nexpiration schedule you follow internally.",
        "Currently, you can use the OAUTH_CLIENT_RSA_PUBLIC_KEY and OAUTH_CLIENT_RSA_PUBLIC_KEY_2 parameters for\nALTER SECURITY INTEGRATION to associate up to 2 public keys with a single user.",
        "To rotate your keys:",
        "Complete the steps in Using key-pair authentication (in this topic):",
        "Generate a new private and public key set.",
        "Assign the public key to the integration. Set the public key value to either OAUTH_CLIENT_RSA_PUBLIC_KEY or\nOAUTH_CLIENT_RSA_PUBLIC_KEY_2 (whichever key value is not currently in use). For example:",
        "Update the code to connect to Snowflake. Specify the new private key.",
        "Snowflake verifies the correct active public key for authentication based on the submitted private key.",
        "Remove the old public key from the integration. For example:",
        "See the Error codes for a list of error codes associated with OAuth, as well as errors that are returned in the JSON\nblob, during the authorization flow, token request or exchange, or when creating a Snowflake session after completing the OAuth flow.",
        "Security administrators (i.e. users with the SECURITYADMIN role) or higher can pre-authorize consent for a client to initiate a session for\na user using a specified role and integration. This consent is granted using ALTER USER with the ADD DELEGATED\nAUTHORIZATION keywords. Without this delegated authorization, a user must authorize consent for the role after authentication. This\ndelegated authorization can also be revoked.",
        "For more information, see Managing user consent for OAuth.",
        "Was this page helpful?",
        "On this page"
    ]
}