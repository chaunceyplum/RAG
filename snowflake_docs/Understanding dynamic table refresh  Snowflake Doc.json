{
    "url": "https://docs.snowflake.com/en/user-guide/dynamic-tables-refresh",
    "title": "Understanding dynamic table refresh | Snowflake Documentation",
    "paragraphs": [
        "Dynamic table content is based on the results of a specific query. When the underlying\ndata on which the dynamic table is based on changes, the table is updated to reflect\nthose changes. These updates are referred to as a refresh. This process is\nautomated, and it involves analyzing the query that underlies the table.",
        "Dynamic table refresh timeouts are determined by the STATEMENT_TIMEOUT_IN_SECONDS\nparameter, defining the maximum duration on the account or the warehouse before it is\nautomatically canceled.",
        "The following sections explain dynamic table refresh in more detail:",
        "Understanding dynamic table initialization",
        "Dynamic table refresh modes",
        "Understanding target lag",
        "Supported queries in incremental refresh",
        "How operators incrementally refresh",
        "Supported non-deterministic functions in full refresh",
        "How data is refreshed when dynamic tables depend on other dynamic tables",
        "The dynamic table refresh process operates in one of two ways:",
        "Incremental refresh: This automated process analyzes the dynamic table\u2019s query and calculates changes since the last refresh. It then merges these changes into the table. See Supported queries in incremental refresh for details on  supported queries.",
        "Full refresh: When the automated process can\u2019t perform an incremental refresh, it conducts a full refresh. This involves executing the query for the dynamic table and completely replacing the previous materialized results.",
        "The constructs used in the query determine whether an incremental refresh can be used.\nAfter you create a dynamic table, you can monitor the table\nto determine whether incremental or full refreshes are used to update that table.",
        "Dynamic table refresh is triggered based on how out of date the data might be, or what is commonly\nreferred to as target lag. The target lag for a dynamic table is measured relative to the base\ntables at the root of the graph, not the dynamic tables directly upstream. Snowflake schedules refreshes\nto keep the actual lag of your dynamic tables below their target lag. The duration of each refresh depends\non the query, data pattern, and warehouse size. When choosing a target lag, consider the time needed to\nrefresh each dynamic table in a chain to the root. If you\ndon\u2019t, some refreshes might be skipped, leading to a higher actual lag.",
        "To see the graph of tables connected to your dynamic table, see\nUse Snowsight to examine the graph of dynamic tables.",
        "Target lag is specified in one of following ways:",
        "Measure of freshness: Defines the maximum amount of time that the dynamic table\u2019s content should lag behind updates to the base tables.",
        "The following example sets the product dynamic table to refresh and maintain freshness every hour:",
        "Downstream: Specifies that the dynamic table should refresh on demand when other dependent dynamic tables refresh. This refresh can be triggered by a manual or scheduled refresh of a downstream dynamic table.",
        "In the following example, product is based on other dynamic tables and is set to refresh based\non the target lag of its downstream dynamic tables:",
        "Target lag is inversely proportional to the dynamic table\u2019s refresh frequency: frequent refreshes imply a lower lag.",
        "Consider the following example where Dynamic Table 2 (DT2) is defined based on Dynamic Table 1 (DT1). DT2\nmust read from DT1 to materialize its contents. In addition, a report consumes DT2 data via a query.",
        "The following results are possible, depending on how each dynamic table specifies its lag:",
        "Dynamic Table 1 (DT1)",
        "Dynamic Table 2 (DT2)",
        "Refresh results",
        "TARGET_LAG = DOWNSTREAM",
        "TARGET_LAG = 10minutes",
        "DT2 is updated at most every 10 minutes. DT1 infers its lag from DT2 and is updated every time DT2\nrequires updates.",
        "TARGET_LAG = 10minutes",
        "TARGET_LAG = DOWNSTREAM",
        "This scenario should be avoided. The report query will not receive any data. DT 1 is frequently\nrefreshed and DT2 is not refreshed as there\u2019s no dynamic table that\u2019s based on DT2.",
        "TARGET_LAG = 5minutes",
        "TARGET_LAG = 10minutes",
        "DT2 is updated approximately every 10 minutes with data from DT1 that\u2019s at most 5 minutes old.",
        "TARGET_LAG = DOWNSTREAM",
        "TARGET_LAG = DOWNSTREAM",
        "DT2 is not refreshed periodically because DT1 has no downstream children with a defined lag.",
        "The following table describes the expressions, keywords, and clauses that currently support incremental refresh.\nFor a list of queries that do not support incremental refresh, see\nLimitations on support for incremental refresh.",
        "Keyword/Clause",
        "Support for Incremental Refreshes",
        "WITH",
        "Common table expressions (CTE) that use incremental refresh supported features in the subquery.",
        "Expressions in SELECT",
        "Expressions including those using deterministic built-in functions and immutable\nuser-defined functions.",
        "FROM",
        "Source tables, views, and other dynamic tables.\nSubqueries outside of FROM clauses (for example, WHERE EXISTS) are not supported.",
        "OVER",
        "All window functions.",
        "WHERE/HAVING/QUALIFY",
        "Filters with the same expressions that are valid in SELECT.",
        "JOIN (and other expressions for joining tables)",
        "Supported join types for incremental refresh include inner joins, outer-equi joins, cross joins, and lateral\nflatten (only the non-static FLATTEN table function). You can specify any number of tables in the join, and\nupdates to all tables in the join are reflected in the results of the query.",
        "Selecting the flatten SEQ column from a lateral flatten join is not supported for incremental refresh.",
        "UNION ALL",
        "Dynamic tables support UNION ALL.",
        "GROUP BY",
        "Dynamic tables support GROUP BY.",
        "Important",
        "If a query uses expressions that are not supported for incremental refresh, the automated refresh process uses a full\nrefresh, which may incur an additional cost. To determine which refresh mode is used, see Determine whether an incremental or full refresh is used.",
        "Replacing an IMMUTABLE user-defined function (UDF) while it\u2019s in use by a dynamic table that uses\nincremental refresh results in undefined behavior in that table. VOLATILE UDFs are not supported with incremental refresh.",
        "Currently, lateral joins are not supported with incremental refresh. However, you can use\nLATERAL with FLATTEN() by setting the refresh mode to INCREMENTAL.",
        "For example:",
        "Note",
        "Selecting the flatten SEQ column from a lateral flatten join is not supported for incremental refresh.",
        "The following table outlines how each operator is incrementalized (that is, how it\u2019s transformed into a\nnew query fragment that generates changes instead of full results) and its performance and other\nimportant factors to consider.",
        "Operator",
        "Incrementalization",
        "Considerations",
        "SELECT <scalar expressions>",
        "Incrementalized by applying expressions to changed rows.",
        "Performs well, no special considerations.",
        "WHERE <scalar expressions>",
        "Incrementalized by evaluating the predicate on each changed row, and including only those for\nwhich the predicate is true.",
        "Generally performs well. Cost scales linearly with size of changes.",
        "Refreshing a dynamic table with a highly selective WHERE expression may require warehouse uptime,\neven if the resulting dynamic table doesn\u2019t change. This is because a warehouse may be required\nto determine which changes in the sources satisfy the predicate.",
        "FROM <base table>",
        "Incrementalized by scanning micro-partitions that were added to or removed from the table since\nthe last refresh.",
        "Cost scales linearly with the volume of data in the added or removed micro-partitions.",
        "Recommendations:",
        "Limit change volume per refresh to about 5% of source table.",
        "Be cautious of DMLs that affect many micro-partitions.",
        "<query> UNION ALL <query>",
        "Incrementalized by taking union-all of changes on each side.",
        "Performs well, no special considerations.",
        "WITH <CTE list> <query>",
        "Incrementalized by computing the changes of each common table expression.",
        "WITH makes complex queries easier to read but be cautious of making the definition of a single\ndynamic table too complex. For more information, see Chain together pipelines of dynamic tables\nand Optimizing incremental refresh mode performance for complex dynamic tables.",
        "Scalar Aggregates",
        "Scalar aggregates are currently not incrementalized efficiently. When their input changes,\nthey\u2019re fully recomputed.",
        "GROUP BY <keys>",
        "Incrementalized by recomputing aggregates for every grouping key that changed.",
        "Ensure the source data is clustered by the grouping keys and the changes comprise a small fraction\n(roughly <5%) of the grouping keys.",
        "If the grouping key contains a compound expression rather than a base column, incremental refreshes\nmight have to scan a large amount of data. To reduce the size of these scans,\nmaterialize the expression in one\ndynamic table, and then apply the grouping operation on the materialized column in another dynamic\ntable.",
        "For instance, take the following compound statement:",
        "The above statement can be optimized as follows:",
        "DISTINCT",
        "Equivalent to GROUP BY ALL with no aggregate functions.",
        "Often represents a substantial optimization opportunity.",
        "It\u2019s a common practice to apply DISTINCT liberally throughout queries to avoid accidentally\nintroducing duplicates. In incremental refresh, DISTINCT operations consume resources on a\nrecurring basis because duplicates have to be checked during every refresh.",
        "When optimizing performance, finding and removing redundant DISTINCTs can be an easy win. You can\ndo this by eliminating duplicates further upstream and considering join cardinalities carefully.",
        "<fn> OVER <window>",
        "Incrementalized by recomputing the window function for every partition key that changed.",
        "Ensure there\u2019s a PARTITION BY clause in your query and the source data is clustered by partition\nkeys. Also ensure the changes comprise a small fraction (roughly <5%) of the partitions.",
        "<left> INNER JOIN <right>",
        "Incrementalized by joining the changes on the left side with the right, then joining the changes\non the right side with the left.",
        "If one of the sides of the join is small, performance is likely good. If one of the sides of\nthe join changes frequently, clustering the other side by the join key might improve performance.",
        "<left> [{LEFT | RIGHT | FULL }] OUTER JOIN <right>",
        "Incrementalized by factoring into an inner-join union-all-ed with one or two NOT EXISTS to compute\nNULLs for non-matches. This factored query is then incrementalized.",
        "The inner join is incrementalized as shown. The not-exists are incrementalized by checking if the\nchanged keys on one side already existed on the other side.",
        "Recommendations:",
        "If one of the sides of the join changes frequently, clustering the other side by the join key\nmight improve performance.",
        "Put the table that changes more frequently on the left side.",
        "Try to minimize changes on the side opposite the OUTER. So for LEFT OUTER, minimize changes on\nthe right side.",
        "For FULL joins, locality is very important.",
        "The following non-deterministic functions are supported in dynamic tables. Note\nthat these functions are only supported for full refreshes. For a list of what is\nnot supported for incremental refresh, see Limitations on support for incremental refresh.",
        "VOLATILE user-defined functions",
        "Sequence functions (e.g., SEQ1, SEQ2)",
        "The following context functions:",
        "CURRENT_ROLE",
        "CURRENT_WAREHOUSE",
        "CURRENT_ACCOUNT",
        "CURRENT_REGION",
        "The following date and time functions (with their respective aliases):",
        "CURRENT_DATE",
        "CURRENT_TIME",
        "CURRENT_TIMESTAMP",
        "When a dynamic table lag is specified as a measure of time, the automated refresh process determines the schedule for refreshes based on the target lag times of the\ndynamic tables. The process chooses a schedule that best meets the target lag times of the tables.",
        "Note",
        "Target lag is not a guarantee. Instead, it is a target that Snowflake attempts to meet.\nData in dynamic tables is refreshed as closely as possible within the target lag. However, target lag may be exceeded\ndue to factors such as warehouse size, data size, query complexity, and similar factors.",
        "In order to keep data consistent in cases when\none dynamic table depends on another, the process refreshes all dynamic tables\nin an account at compatible times. The timing of less frequent refreshes coincides with the timing of more frequent refreshes.",
        "For example, suppose that dynamic table A has a target lag of two minutes and queries dynamic table B that has a target lag of\none minute. The process might determine that A should be refreshed every 96 seconds, and B every 48 seconds. As a result, the\nprocess might apply the following schedule:",
        "Specific Point in Time",
        "Dynamic Tables Refreshed",
        "2022-12-01 00:00:00",
        "A, B",
        "2022-12-01 00:00:48",
        "B",
        "2022-12-01 00:01:36",
        "A, B",
        "2022-12-01 00:02:24",
        "B",
        "This means that at any given time, when you query a set of dynamic tables that depend on each other, you are querying the same\n\u201csnapshot\u201d of the data across these tables.",
        "Note that the target lag of a dynamic table cannot be shorter than the target lag of the dynamic tables it depends on. For\nexample, suppose that:",
        "Dynamic table A queries the dynamic tables B and C.",
        "Dynamic table B has a target lag of five minutes.",
        "Dynamic table C has a target lag of one minute.",
        "This means that the target lag time for A must not be shorter than five minutes (that is, not shorter than the longer of the lag times\nfor B and C).",
        "If you set the lag for A to five minutes, the process sets up a refresh schedule with these goals:",
        "Refresh C often enough to keep its lag below one minute.",
        "Refresh A and B together and often enough to keep their lags below five minutes.",
        "Ensure that the refresh for A and B coincides with a refresh of C to ensure snapshot isolation.",
        "Note: If refreshes take too long, the scheduler may skip refreshes to try to stay up to date. However, snapshot isolation is\npreserved.",
        "Was this page helpful?",
        "On this page"
    ]
}