{
    "url": "https://docs.snowflake.com/en/user-guide/classify-classic",
    "title": "Use sensitive data classification with the classic APIs | Snowflake Documentation",
    "paragraphs": [
        "Enterprise Edition Feature",
        "This feature requires Enterprise Edition or higher. To inquire about upgrading, please contact Snowflake Support.",
        "This topic provides examples of classifying data with the classic APIs in Snowflake:\nEXTRACT_SEMANTIC_CATEGORIES and ASSOCIATE_SEMANTIC_CATEGORY_TAGS.\nThese APIs are no longer being updated to coincide with updates to Data Classification.",
        "You can continue to use these APIs. However, you should update your workflows to use the approaches as shown in\nClassify sensitive data manually.",
        "The following examples for classifying data address different use cases based on scope:",
        "Classify a single table",
        "Classify all tables in a schema",
        "Classify all tables in a database",
        "If you are a new Classification user, start with classifying a single table and then proceed to the other two examples.",
        "The examples in this topic use the table and custom roles shown below:",
        "Table: my_db.my_schema.hr_data, which contains data about employees.",
        "Roles:",
        "data_engineer: classifies tables.",
        "policy_admin: protects personal information with a masking policy.",
        "analyst: serves as an example of a custom role for which you might want to restrict access. The examples assume this role exists.",
        "Database roles:",
        "GOVERNANCE_ADMIN: assigns the Classification system tags.",
        "GOVERNANCE_VIEWER: queries the Account Usage views relating to tags and masking policies.",
        "Create the table:",
        "Load the table (details not shown).",
        "Create the custom roles and grant the necessary privileges to those roles.",
        "The data_engineer role needs access to the table to run the Classification process. Note that this example grants the\nGOVERNANCE_ADMIN database role to the data_engineer role because you can not switch roles to a database role:",
        "The policy_admin custom role needs to assign a masking policy to any column containing PII data:",
        "The single table example expands on the three-step Classification process (i.e. analyze, review, and apply) to apply the results to\nrevoke table access from the analyst custom role.",
        "In this step, the data_engineer runs the Classification process and the policy_admin protects the column data with a\nmasking policy.",
        "Analyze: Use the data_engineer custom role to call the EXTRACT_SEMANTIC_CATEGORIES function to\nclassify the columns in the table named my_db.my_schema.hr_data:",
        "Review: The data engineer reviews the results to ensure they make sense.",
        "Apply: The data engineer assigns a Classification system tag to the columns.",
        "The data engineer has two options: automated assignment or manual assignment.",
        "To assign the system tags automatically, call the ASSOCIATE_SEMANTIC_CATEGORY_TAGS stored\nprocedure. Note:",
        "The fully-qualified name of the table and the function from the first step are arguments for the stored procedure.",
        "The stored procedure reruns the EXTRACT_SEMANTIC_CATEGORIES function. If you want to preserve the results from the first step, save\nthe results to a table prior to calling the stored procedure.",
        "If the stored procedure executes successfully, it returns a message similar to the following:\nApplied tag semantic_category to <n> columns. Applied tag privacy_category to <n> columns.",
        "Otherwise, when the stored procedure doesn\u2019t execute or if the decision is to assign the Classification system tag to each column as needed manually, use an ALTER TABLE \u2026 ALTER COLUMN statement. For example, assign either system tag to the\nFNAME column (i.e. first name).",
        "or",
        "This step assumes that several columns in the my_db.my_schema.hr_data table have the PRIVACY_CATEGORY = 'IDENTIFIER' tag\nassigned to these columns and that there is a need to protect these columns with a masking policy.",
        "To protect these columns:",
        "Use the policy_admin role to find the columns that have the IDENTIFIER privacy tag applied:",
        "The latency for the TAG_REFERENCES view can be up to 120 minutes. If you need\nresults sooner and know the name of the column for which you are querying the classification tags, you can use the\nTAG_REFERENCES or TAG_REFERENCES_ALL_COLUMNS table functions instead.",
        "Use the policy_admin role to apply masking policies to the appropriate columns. For example, the following statement applies the\nidentifier_mask masking policy to the fname column:",
        "Finally, the security administrator (i.e. a user with the SECURITYADMIN role):",
        "Queries the TAG_REFERENCES view to find all the columns with the IDENTIFIER privacy tag value.",
        "Revokes the SELECT privilege for the analyst custom role on tables for which the PRIVACY_CATEGORY = 'IDENTIFIER' tag is set\non a column:",
        "Tip",
        "You do not need to use the SECURITYADMIN system role to perform these tasks; you can use any custom role that has been assigned the\nnecessary privileges.",
        "This example shows how to classify all the tables in a schema using two user-defined stored procedures:",
        "classify_schema: Lists all the tables in the schema, creates a table to store the classification results, and then extracts\nthe classification tags from each table and stores them in the results table.",
        "associate_tag_batch: Uses the results of the classify_schema stored procedure to assign the Classification system\ntags to all table columns in the schema automatically and returns the number of tags assigned to each table.",
        "Important",
        "The stored procedure named classify_schema creates a temporary table to store results. The temporary table exists for the\nduration of the user session for the user that calls this stored procedure. When the user session expires, Snowflake drops the temporary\ntable and the user needs to call the stored procedure again to recreate the temporary table.",
        "If the temporary table needs to be preserved, remove the temp keyword from the sqlText command to create the table.",
        "For more details, see the TEMP[ORARY] option in the CREATE TABLE command.",
        "Create the first procedure named classify_schema:",
        "Create the second procedure named associate_tag_batch:",
        "Call the classify_schema stored procedure, using the name of the schema you would like to classify and the name of a temporary\ntable to hold the results of EXTRACT_SEMANTIC_CATEGORY for each table as the arguments:",
        "Review the results in the temporary table and modify as necessary.",
        "When satisfied with the results, call the associate_tag_batch stored procedure to assign the Classification system tags to the table\ncolumns:",
        "This example shows how to classify all the tables in a database by using two stored procedures:",
        "classify_database: Classifies all tables within a schema for each schema in the database, and returns the number of tables and the\nnumber of schemas that are classified.",
        "associate_tag_batch: Performs the same operations as defined in Classify all tables in a schema (in this topic).",
        "Create the classify_database stored procedure:",
        "Call the classify_database stored procedure with the name of the database you wish to classify and the name of the temporary\ntable to store the results in each schema of the database:",
        "Navigate to each schema and review the temporary table and revise if necessary.",
        "When satisfied with the results, call the associate_tag_batch stored procedure once for each schema to apply the tags to\nthe tables in that schema. For example, if the database contains three schemas, call the stored procedure three times:",
        "Was this page helpful?",
        "On this page"
    ]
}