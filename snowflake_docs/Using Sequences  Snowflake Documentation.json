{
    "url": "https://docs.snowflake.com/en/user-guide/querying-sequences",
    "title": "Using Sequences | Snowflake Documentation",
    "paragraphs": [
        "Sequences are used to generate unique numbers across sessions and statements, including concurrent statements. They can be used to generate\nvalues for a primary key or any column that requires a unique value.",
        "Important",
        "Snowflake does not guarantee generating sequence numbers without gaps. The generated numbers are not necessarily contiguous.",
        "Snowflake sequences currently utilize the following semantics:",
        "All values generated by a sequence are globally unique as long as the sign of the sequence interval does not change (e.g. by changing\nthe step size). Concurrent queries never observe the same value, and values within a single query are always distinct.",
        "Changing the sequence interval from positive to negative (e.g. from 1 to -1), or vice versa may result in\nduplicates. For example, if the first query(s) return sequence values 1, 2, and 3, and if the interval\nis changed from 1 to -1, then the next few values generated include 2, and 1, which were\ngenerated previously.",
        "Snowflake may calculate the next value for a sequence as soon as the current sequence number is used, rather than waiting\nuntil the next sequence number is requested.",
        "A consequence of this is that an ALTER SEQUENCE ... SET INCREMENT ... command might not affect the next operation\nthat uses the sequence. For an example, see Understanding the Effects of Reversing the Direction of a Sequence.",
        "Each generated sequence value additionally reserves values depending on the sequence interval, also called the \u201cstep\u201d. The\nreserved values span from the sequence value to",
        "<value>\u00a0 +\u00a0 (sign(<step>) * abs(<step>))\u00a0 -\u00a0 (sign(<step>) * 1)",
        "(inclusive).",
        "Thus, if the value 100 is generated:",
        "With a step of 2, values 100 and 101 are reserved.",
        "With a step of 10, values 100 to 109 are reserved.",
        "With a step of -5, values 96 to 100 are reserved.",
        "A reserved value is never generated by the sequence as long as the step/interval is never modified.",
        "Values generated by a sequence are greater than the maximum value produced by a previous statement (or less than the\nminimum value if the step size is negative) if the following are true:",
        "The sequence does not have the NOORDER property.",
        "NOORDER specifies that the values are not guaranteed to be in increasing order.",
        "For example, if a sequence has START 1 INCREMENT 2, the generated values might be 1, 3, 101, 5, 103, etc.",
        "NOORDER can improve performance when multiple INSERT operations are performed concurrently (for example, when multiple\nclients are executing multiple INSERT statements).",
        "The previous statement completed, and an acknowledgment was received, prior to submitting the current statement.",
        "This behavior does not hold if the sign of the interval is changed (positive to negative or negative to positive).",
        "There is no guarantee that values from a sequence are contiguous (gap-free) or that the sequence values are assigned in a particular order.\nThere is, in fact, no way to assign values from a sequence to rows in a specified order other than to use single-row statements (this still\nprovides no guarantee about gaps).",
        "A sequence value can represent a 64-bit two\u2019s complement integer (-2^63 to 2^63 - 1). If the internal representation of a\nsequence\u2019s next value exceeds this range (in either direction) an error results and the query fails. Note that this may result in\nlosing these sequence values.",
        "In this situation, you must either use a smaller (in magnitude) increment value or create a new sequence with a smaller start value. As gaps\nmay occur, the internal representation of the next value may exceed the allowable range even if the returned sequence values are all within\nthe allowable range. Snowflake does not provide an explicit guarantee regarding how to avoid this error, but Snowflake supports sequence\nobjects that correctly provide unique values. A sequence object created with a start value of 1 and an increment value of\n1 is extremely unlikely to exhaust the allowable range of sequence values.",
        "Many databases provide a currval sequence reference; however, Snowflake does not. currval in other systems is typically used\nto create primary-foreign key relationships between tables \u2014 a first statement inserts a single row into the fact table using a sequence\nto create a key. Subsequent statements insert rows into the dimension tables using currval to refer to the fact table\u2019s key.",
        "This pattern is contrary to Snowflake best practices \u2014 bulk queries should be preferred over small, single-row queries. The same task can be\nbetter accomplished using multi-table INSERT and sequence references in nested subqueries.\nFor a detailed example, see Ingesting and Normalizing Denormalized Data (in this topic).",
        "Sequences may be accessed in queries as expressions of the form seq_name.NEXTVAL. Each occurrence of a sequence generates a set of\ndistinct values. This is different from what many other databases provide, where multiple references to NEXTVAL of a sequence return\nthe same value for each row.",
        "For example, the following query returns distinct values for columns a and b:",
        "To return two columns with the same generated sequence value, use nested subqueries and views:",
        "Nested subqueries generate as many distinct sequence values as rows returned by the subquery (so a sequence reference in a query block\nwith several joins refers not to any of the joined objects, but the output of the query block). These generated values may not be observed\nif the associated rows are later filtered out, or the values may be observed twice (as in the above example) if the sequence column or the\ninline view are referred to multiple times.",
        "Note",
        "For multi-table insert, insert values may be provided both in the VALUES clauses and in the SELECT input:",
        "VALUES clauses referring to a sequence value aliased from the input SELECT receive the same value.",
        "VALUES clauses containing a direct reference to a sequence NEXTVAL receive distinct values.",
        "In contrast, Oracle restricts sequence references to VALUES clauses only.",
        "Nested queries with sequence references are often difficult to understand and verbose \u2014 any shared reference (where two columns of a row\nshould receive the same sequence value) requires an additional level of query nesting. To simplify nested-query syntax, Snowflake provides\nan additional method to generate sequences using the table function GETNEXTVAL, as in the following example:",
        "GETNEXTVAL is a special 1-row table function that generates a unique value (and joins this value) to other objects in the SELECT statement.\nA call to GETNEXTVAL must be aliased; otherwise, the generated values cannot be referenced. Multiple columns may refer to a generated value\nby accessing this alias. The GETNEXTVAL alias contains an attribute also named NEXTVAL.",
        "The GETNEXTVAL table function additionally allows precise control over sequence generation when many tables are joined together. The order of\nobjects in the FROM clause determines where values are generated. Sequence values are generated over the\nresult of joins between all objects listed prior to GETNEXTVAL in the FROM clause. The resulting rows are then joined to the objects to the\nright. There is an implicit lateral dependence between GETNEXTVAL and all other objects in the FROM clause. Joins may not reorder around\nGETNEXTVAL. This is an exception in SQL, as typically the order of objects does not affect the query semantics.",
        "Consider the following example with tables t1, t2, t3, and t4:",
        "This query will join t1 to t2, generate a unique value of the result, and then join the resulting relation against t3\nand t4. The order of joins between the post-sequence relation, t3, and t4 is not specified because inner joins are\nassociative.",
        "Note",
        "These semantics can be tricky. We recommend using GETNEXTVAL at the end of the FROM clause, when possible\nand appropriate, to avoid confusion.",
        "Sequences can be used in tables to generate primary keys for table columns. The following tools provide a simple way to do this.",
        "The column default expression can be a sequence reference. Omitting the column in an insert statement or setting the value to DEFAULT in an\ninsert or update statement will generate a new sequence value for the row.",
        "For example:",
        "The advantage of using sequences as a column default value is that the sequence can be referenced in other locations, and even be the default\nvalue for multiple columns and in multiple tables. If a sequence is named as the default expression of a column and then subsequently dropped\nany attempt to insert/update the table using the default value will result in an error saying the identifier cannot be found.",
        "Consider a schema with two tables, people and contact:",
        "The people table contains:",
        "A primary key unique identifier: id",
        "Two string columns: firstName and lastName",
        "The contact table contains:",
        "A primary key unique identifier: id",
        "A foreign key linking this contact entry to a person: p_id",
        "Two string columns:",
        "c_type: The type of contact (e.g. \u2018email\u2019 or \u2018phone\u2019).",
        "data: The actual contact information.",
        "Data in this format frequently is denormalized for ingestion or while processing semi-structured data.",
        "This example illustrates ingesting JSON data, denormalizing it to extract the desired data, and normalizing the data as it is inserted into\ntables. At the same time, it is important to create unique identifiers on rows while maintaining the intended relationships across rows of\ntables. We accomplish this with sequences.",
        "First, we set up the tables and sequences used in the example:",
        "Next, we insert data from table json:",
        "Then, we parse and flatten the JSON, generate unique identifiers for each person and contact entry, and insert the data while preserving\nrelationships between people and contact entries:",
        "This produces the following data (unique IDs may change):",
        "As you can see, rows are linked, and can be joined, between people.id and contact.p_id.",
        "If additional data is added, new rows continue to receive unique IDs. For example:",
        "The following example shows what happens when you reverse the direction of a sequence.",
        "This also shows that due to pre-calculation of sequence values, an ALTER SEQUENCE command might seem to take effect only after\nthe second use of the sequence after executing the ALTER SEQUENCE command.",
        "Create the sequence and use it as the default value for a column in a table:",
        "Load the table:",
        "Show the sequence values in column j:",
        "Alter the increment (step size) of the sequence:",
        "Insert two more rows:",
        "Show the sequence values. Note that the first row inserted after the ALTER SEQUENCE\nhas the value 4, not -1. The second row inserted after the ALTER SEQUENCE\ndoes take into account the new step size.",
        "Was this page helpful?",
        "On this page"
    ]
}