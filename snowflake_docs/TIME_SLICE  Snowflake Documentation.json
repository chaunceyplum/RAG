{
    "url": "https://docs.snowflake.com/en/sql-reference/functions/time_slice",
    "title": "TIME_SLICE | Snowflake Documentation",
    "paragraphs": [
        "Date & time functions",
        "Calculates the beginning or end of a \u201cslice\u201d of time, where the length of the slice is a multiple of a standard unit of time\n(minute, hour, day, etc.).",
        "This function can be used to calculate the start and end times of fixed-width \u201cbuckets\u201d into which data can be categorized.",
        "DATE_TRUNC",
        "Required:",
        "The function returns the start or end of the slice that contains this date or time. The expression must\nbe of type DATE or TIMESTAMP_NTZ.",
        "This indicates the width of the slice (i.e. how many units of\ntime are contained in the slice). For example, if the unit is MONTH and the slice_length\nis 2, then each slice is 2 months wide. The slice_length must be an integer\ngreater than or equal to 1.",
        "Time unit for the slice length. The value must be a string containing one of the values listed\nbelow:",
        "If input expression is a DATE: YEAR, QUARTER, MONTH, WEEK, DAY.",
        "If input expression is a TIMESTAMP_NTZ: YEAR, QUARTER, MONTH, WEEK, DAY, HOUR, MINUTE, SECOND.",
        "The values are case-insensitive.",
        "Optional:",
        "This is an optional constant parameter that determines whether the start or end of the slice should be returned.",
        "Supported values are \u2018START\u2019 or \u2018END\u2019. The values are case-insensitive.",
        "The default value is \u2018START\u2019.",
        "The data type of the return value is identical to the data type of the input date_or_time_expr\n(i.e. either TIMESTAMP_NTZ or DATE).",
        "All slices are aligned relative to midnight January 1, 1970 (1970-01-01 00:00:00).",
        "Most slices start on an integer multiple of the slice length relative to January 1, 1970. For example, if you choose\na slice length of 15 years, then each slice will start on one of the following boundaries:",
        "January 1, 1970.",
        "January 1, 1985.",
        "January 1, 2000.",
        "January 1, 2015.",
        "Etc.",
        "Dates prior to January 1, 1970 are also valid; for example, a 15-year slice can start on January 1, 1955.",
        "The one exception is that, for slices measured in weeks, the starts of the slices are aligned with the beginning of\nthe week that contains January 1, 1970. January 1, 1970 was a Thursday. So, for example, if your\nWEEK_START session parameter specifies that your calendar weeks start on Monday, and if your slices\nare 2 weeks, then your slices will start on one of the following boundaries:",
        "December 29, 1969 (Monday).",
        "January  12, 1970 (Monday).",
        "January  25, 1970 (Monday).",
        "Etc.",
        "If your calendar weeks start on Sunday, then your slices will start on:",
        "December 28, 1969 (Sunday).",
        "January  11, 1970 (Sunday).",
        "January  25, 1970 (Sunday).",
        "Etc.",
        "For more details about how calendar weeks are handled, including examples, see Calendar weeks and weekdays.",
        "Although the parameters to TIME_SLICE must be of type DATE or TIMESTAMP_NTZ, you can use casting to process\nTIMESTAMP_LTZ values. For TIMESTAMP_LTZ values, cast the input to TIMESTAMP_NTZ first and then cast back\nto TIMESTAMP_LTZ. However, in this case, slices crossing daylight saving time boundaries can be either one hour\nlonger or one hour shorter than slices that do not cross daylight saving time boundaries.",
        "The end of each slice is the same as the beginning of the following slice. For example, if the slice is\n2 months and the start of the slice is 2019-01-01, then the end of the slice will be 2019-03-01, not\n2019-02-28. In other words, the slice contains dates or timestamps greater than or equal to the start\nand less than (but not equal to) the end.",
        "Find the start and end of a 4-month slice containing a date:",
        "Find the start of 8-hour slices corresponding to two timestamps:",
        "Group data into \u201cbuckets\u201d based on the date or timestamp (e.g. group data into buckets that are two weeks wide):",
        "This example uses the table and data created below:",
        "This query shows the bucketed data:",
        "Note that the GROUP BY clause needs both the start of the slice and the end of the slice because the compiler\nexpects the GROUP BY clause to contain all non-aggregate expressions of the projection clause.",
        "Was this page helpful?",
        "On this page"
    ]
}