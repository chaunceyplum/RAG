{
    "url": "https://docs.snowflake.com/en/user-guide/dynamic-tables-cost",
    "title": "Understanding cost for dynamic tables | Snowflake Documentation",
    "paragraphs": [
        "This topic provides an overview of the compute and storage costs associated with dynamic tables. For\ngeneral information about Snowflake costs, see Understanding overall cost.",
        "There are two compute costs associated with dynamic tables: virtual warehouses and Cloud Services compute.",
        "Dynamic tables require virtual warehouses to refresh - that\nis, run queries against base objects when they are initialized and refreshed, including both scheduled and\nmanual refreshes. These operations use compute resources, which consume credits.",
        "Dynamic tables also require Cloud Services compute to identify\nchanges in underlying base objects and whether the virtual warehouse needs to be invoked. If no changes are\nidentified, virtual warehouse credits aren\u2019t consumed since there\u2019s no new data to refresh. Note that there\nmay be instances where changes in base objects are filtered out in the dynamic table query. In such scenarios,\nvirtual warehouse credits are consumed because the dynamic table undergoes a refresh to determine whether the\nchanges are applicable.",
        "If the associated virtual warehouse is suspended and no changes in base objects are identified, the suspended\nvirtual warehouse doesn\u2019t get invoked and no credits are consumed. Conversely, if changes are identified, the\nvirtual warehouse is automatically resumed to process the updates.",
        "Dynamic table refreshes are driven by the configured target lag.\nDynamic table pipelines with lower target lag refresh more often and therefore incur higher compute costs.",
        "You can use the Refresh History tab in Snowsight to check if virtual warehouse credits were\nconsumed:",
        "In the navigation menu, select Monitoring \u00bb Dynamic Tables.",
        "Select your dynamic table and go to the Refresh History tab. Check the Warehouse used only checkbox to view refreshes that used the warehouse to update.",
        "Tip",
        "To get a clear understanding of costs related to your dynamic table pipelines, Snowflake recommends testing\ndynamic tables using dedicated warehouses so that the virtual warehouse consumption attributed to dynamic\ntables can be isolated. You can move your dynamic tables to a shared warehouse after you establish a cost\nbaseline.",
        "Dynamic tables require storage to store the materialized results. Similar to regular tables, you may incur\nadditional storage cost for Time Travel, fail-safe storage, and cloning feature.",
        "This section discusses the following storage considerations for dynamic tables:",
        "Time Travel and fail-safe storage",
        "Replication of dynamic tables",
        "Suspended dynamic tables",
        "Transient dynamic tables",
        "Additional storage for incremental refresh operations",
        "For detailed information about how this storage incurs cost, see Understanding storage cost\nand Data storage considerations.",
        "Snowflake Time Travel enables you to access and query historical versions of dynamic tables at specific points\nin time, which can help provide insights into historical trends, changes, and anomalies in your data. Note that\nfrequent refreshes can increase buildup of Time Travel data, which adds to your overall storage usage. For more\ninformation, see Understanding & using Time Travel.",
        "Fail-safe features help protect your dynamic tables from data loss or corruption. Based on the configured\nfail-safe period, additional storage charges might apply.",
        "Dynamic tables support cross-account, cross-region replication, which enables you to copy data from a primary\ndatabase to a secondary database for either disaster recovery or data sharing. It can serve as either a\nfailover preparation strategy for disaster recovery or as a means of sharing data across deployments for\nread-only purposes. Using replication with dynamic tables is subject to\nreplication costs. For more information, see\nReplication and dynamic tables.",
        "Suspended dynamic tables don\u2019t incur additional costs beyond standard storage fees and don\u2019t consume compute\nresources. If there are ongoing maintenance tasks or scheduled jobs that interact with the suspended table,\ncompute resources might be consumed.",
        "Snowflake supports transient dynamic tables, similar to regular\ntables, that persist until explicitly dropped, and are available to all users with the appropriate privileges\nwithout a fail-safe period. Transient dynamic tables are best used for transitory data that doesn\u2019t need the\nsame level of data protection and recovery provided by permanent tables, helping save on storage charges for\nfail-safe storage.",
        "For incremental refresh operations, dynamic tables maintain an additional internal metadata column for\nidentifying each row within the table. Internal row identifiers consume a constant amount of storage per row\nand increase storage cost linearly to the number of rows in the table (independent of the number of columns).\nFor tables with very few columns, the increase in storage compared to an equivalent CTAS\ntable can be significant, or even dominant. In wider dynamic tables, this effect is less pronounced.",
        "The schedule at which a dynamic table refreshes, whether\nfull or incremental, has an effect on its overall cost.\nThis section discusses the factors to consider when deciding on a refresh schedule (with the assumption\nthat every refresh is non-empty):",
        "Full refresh schedule",
        "Incremental refresh schedule",
        "Note",
        "Refreshes are relatively inexpensive if the sources haven\u2019t changed. For more information, see\nCompute cost (in this topic).",
        "The cost of full refresh typically depends on the data scanned and the refresh frequency. To save on\ncosts, you can refresh your dynamic tables only when needed - for example, suspend your dynamic tables\noutside of business hours. For precise timing control, set\ndownstream target lag for your dynamic tables and use\nmanual refresh from a task\nto automate custom schedules.",
        "The cost of incremental refresh is typically proportional to the volume of changes in the source objects,\nplus some fixed overhead.",
        "If the overhead is low, you can set a high refresh frequency without much downside. This means you can\nrefresh often for best results. For instance, a simple SELECT ... FROM ... WHERE dynamic table\nonly processes changed rows between refreshes, which has minimal overhead and can run frequently at low\nadded cost.",
        "If the overhead is high, you must balance the credit consumption of high refresh frequency and the\nbusiness benefits of freshness. For example, in a dynamic table with a join, the changes in one table\nmust be joined with the other table. No matter how small the set of changes, this join usually involves\na minimum cost to execute. If this overhead is significant, it can accumulate as the refresh frequency\nincreases.",
        "Was this page helpful?",
        "On this page"
    ]
}